1
00:00:00,000 --> 00:00:08,342
[MUSIC]

2
00:00:08,342 --> 00:00:11,786
So let's take a look a this bit of code
that we've got here.

3
00:00:11,786 --> 00:00:14,874
That's trying to make it so that we have

4
00:00:14,874 --> 00:00:19,600
a flexible mechanism for storing data on a
device.

5
00:00:19,600 --> 00:00:25,042
And so in this example, we have developer
who's gone through and built an ex,

6
00:00:25,042 --> 00:00:28,258
an extraction called a storage handler,
that

7
00:00:28,258 --> 00:00:31,484
can be plugged into this data storage
system.

8
00:00:31,484 --> 00:00:33,768
And we can have different types of storage

9
00:00:33,768 --> 00:00:37,170
handlers plugged in that are both public
and private.

10
00:00:37,170 --> 00:00:41,590
So, for example, a public storage handler
can store data to the SD card.

11
00:00:41,590 --> 00:00:45,890
Whereas a private storage handler can save
it to the app's private data storage

12
00:00:45,890 --> 00:00:48,750
and encrypt it or do other things to it to
make it hard to access.

13
00:00:50,580 --> 00:00:54,880
So, it has become a much more complicated
problem to look

14
00:00:54,880 --> 00:01:00,440
at this code, and suddenly decide, is this
code secure or not?

15
00:01:00,440 --> 00:01:02,410
Is it leaking data under the SD card?

16
00:01:03,680 --> 00:01:08,284
One of the areas of, of difficulty in
understanding how this

17
00:01:08,284 --> 00:01:12,740
code works, is we have a common interface
restoring all data.

18
00:01:12,740 --> 00:01:17,220
That is, all data we're storing is going
through the same method.

19
00:01:18,400 --> 00:01:21,660
In this case it's this stored data method.

20
00:01:21,660 --> 00:01:23,969
That takes a key end value and stores it.

21
00:01:25,210 --> 00:01:27,670
So, when you look at this, take a

22
00:01:27,670 --> 00:01:31,070
second and say, can you immediately spot
the error?

23
00:01:32,110 --> 00:01:36,080
And if you did see this code, would you
think that it was bad code?

24
00:01:36,080 --> 00:01:39,590
Would you think that it was well
structured and modular code?

25
00:01:39,590 --> 00:01:43,270
And probably, whoever built it knew what
they were doing?

26
00:01:43,270 --> 00:01:45,308
Or would you be suspicious of it because
it's not

27
00:01:45,308 --> 00:01:48,350
as simple and straightforward as the
examples that we've seen before.

28
00:01:49,890 --> 00:01:52,080
Let's stop and take a second to look at

29
00:01:52,080 --> 00:01:54,930
what this code is actually doing, and
it'll help us

30
00:01:54,930 --> 00:01:58,310
to decide if we like this approach and the
series

31
00:01:58,310 --> 00:02:00,750
of abstractions that this code is built on
top of.

32
00:02:01,910 --> 00:02:04,426
The most basic, we have a set of key value

33
00:02:04,426 --> 00:02:08,360
pairs that are being stored on the
underlying storage system.

34
00:02:08,360 --> 00:02:13,510
And we take these key value pairs, and we
pass them to a method called store data.

35
00:02:15,870 --> 00:02:25,096
And what store data does is then, based on
the key, it extracts a type from the data.

36
00:02:25,096 --> 00:02:32,616
So we're going to read into the key, and
we're going to extract the type.

37
00:02:32,616 --> 00:02:38,976
And then based on the type, it's going to
look up a handler that

38
00:02:38,976 --> 00:02:44,983
can do the actual storage for that
particular type of data.

39
00:02:44,983 --> 00:02:49,991
And then ask the handler to, and this our
storage

40
00:02:49,991 --> 00:02:54,634
handler not an android handler, to store
the

41
00:02:54,634 --> 00:02:59,764
data and then the handler itself may go
and store in

42
00:02:59,764 --> 00:03:04,895
different locations either the SD card if
it's an

43
00:03:04,895 --> 00:03:10,391
insecure one, or it may get stored down to
the private

44
00:03:10,391 --> 00:03:12,890
data of that app.

45
00:03:12,890 --> 00:03:18,830
And all of this is dependent upon the key
that is put into this store data method.

46
00:03:19,930 --> 00:03:24,117
If that key has a type that says that it's
okay to be stored on the

47
00:03:24,117 --> 00:03:28,620
SD card, then the app will store go ahead
and store it on the SD card.

48
00:03:28,620 --> 00:03:32,357
If the key has an attribute that says it
should be private, then the

49
00:03:32,357 --> 00:03:37,320
store data method is going to look up the
appropriate handler for private data.

50
00:03:37,320 --> 00:03:40,227
And store it in the apps private data

51
00:03:40,227 --> 00:03:43,915
maybe encrypt it, or applying other things
to it.

52
00:03:43,915 --> 00:03:45,678
Now, if we look at this from a

53
00:03:45,678 --> 00:03:49,794
software engineering or maybe a software
design perspective this

54
00:03:49,794 --> 00:03:53,247
doesn't look all bad we've got an
abstraction that's

55
00:03:53,247 --> 00:03:56,860
used to provide modularity inside the
store data method.

56
00:03:56,860 --> 00:04:02,120
That is, these handlers allow us to plugin
new handler implementations.

57
00:04:02,120 --> 00:04:05,880
We've got different handlers that are
dedicated to different functions.

58
00:04:05,880 --> 00:04:10,850
So, it appears like we're building a nice
set of abstractions for storing data.

59
00:04:13,500 --> 00:04:17,636
Now, let's take a look and dive a little
bit deeper into one

60
00:04:17,636 --> 00:04:24,170
aspect of this application, and that's
this extraction of a type from the key.

61
00:04:24,170 --> 00:04:26,894
We see that the first thing that we do in
order

62
00:04:26,894 --> 00:04:31,030
to derive this type, is we're extracting a
suffix from the type.

63
00:04:31,030 --> 00:04:37,130
So we're looking for the end dot something
on the keys that are provided.

64
00:04:37,130 --> 00:04:41,011
And the idea behind this is that, any key,
that has

65
00:04:41,011 --> 00:04:45,360
.puser on it, is going to be assumed to be
private data.

66
00:04:45,360 --> 00:04:51,880
And any key that has .group on it, is
going to be assumed to be public data.

67
00:04:52,930 --> 00:04:55,980
And then, based on these keys, these,
these

68
00:04:55,980 --> 00:04:59,270
suffixes that are being attached to the
keys.

69
00:04:59,270 --> 00:05:03,280
The actual code is going in looking up the
appropriate

70
00:05:03,280 --> 00:05:06,810
handler, and delegating to it by calling
the store method.

71
00:05:06,810 --> 00:05:10,600
So, it's looking up the handler in this
map, using that type.

72
00:05:11,700 --> 00:05:14,570
Now, why is this a problem?

73
00:05:14,570 --> 00:05:17,420
Well, let's look at this specific code
example.

74
00:05:17,420 --> 00:05:21,551
If we look down in our Save Settings
method, one of the things that we

75
00:05:21,551 --> 00:05:24,014
can see is that we're saving the private

76
00:05:24,014 --> 00:05:28,200
groups, whatever that is, for this
particular app.

77
00:05:28,200 --> 00:05:33,340
And we are creating a key, that's called a
private.groups.puser.

78
00:05:33,340 --> 00:05:37,559
So this is clearly data that the developer
intended to be private.

79
00:05:38,610 --> 00:05:44,750
Now, if we look a little farther up, what
we see is, suddenly we have a problem now.

80
00:05:44,750 --> 00:05:52,160
Because this expression that's being used
to extract the type from the key,

81
00:05:52,160 --> 00:05:55,570
in this case what we're doing a series of
substring operations on the string.

82
00:05:56,840 --> 00:06:00,230
The developer didn't think through the
fact that

83
00:06:00,230 --> 00:06:03,660
there might be keys that had dots within
them.

84
00:06:03,660 --> 00:06:05,900
And we might end up in a situation where

85
00:06:05,900 --> 00:06:09,880
we could extract the incorrect type from
the key.

86
00:06:09,880 --> 00:06:15,525
So if we actually apply this function to
the private.groups.puser,

87
00:06:15,525 --> 00:06:20,520
what we get is groups is what this thing
thinks is the suffix.

88
00:06:20,520 --> 00:06:24,110
This expression thinks that groups is the
suffix,

89
00:06:24,110 --> 00:06:26,948
when in reality .puser is supposed to be

90
00:06:26,948 --> 00:06:30,453
the suffix, but because it thinks it's
groups,

91
00:06:30,453 --> 00:06:34,270
it extracts groups and uses that as the
type.

92
00:06:34,270 --> 00:06:37,490
Which then causes the public storage
handler to get

93
00:06:37,490 --> 00:06:39,760
used, which stores this data onto the SD
card.

94
00:06:40,860 --> 00:06:44,370
So in this case, it wasn't directly
obvious

95
00:06:44,370 --> 00:06:47,590
that the developer was doing the wrong
thing.

96
00:06:47,590 --> 00:06:52,856
But the fact that the user was, had to
write code that used this interface that

97
00:06:52,856 --> 00:06:57,820
had a series of abstractions, that hid the
actual function of the code.

98
00:06:57,820 --> 00:07:00,305
It made it difficult to see that private

99
00:07:00,305 --> 00:07:03,403
data was actually being leaked onto the SD
card.

100
00:07:03,403 --> 00:07:06,511
And, you know, certainly there are, there
are developers that

101
00:07:06,511 --> 00:07:09,518
make mistakes and do the obvious things
that we've looked at.

102
00:07:09,518 --> 00:07:13,082
But probably most of the mistakes that we
see out there from a security

103
00:07:13,082 --> 00:07:16,966
perspective, or at least I hope they are,
are from this type of scenario.

104
00:07:16,966 --> 00:07:21,782
Where we have a complex set of
abstractions that cause the developer

105
00:07:21,782 --> 00:07:26,440
not to see a mistake in their code that
causes a security problem.

