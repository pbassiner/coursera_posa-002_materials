1
00:00:00,203 --> 00:00:08,068
[MUSIC]

2
00:00:08,068 --> 00:00:13,249
So today, we're going to talk about the
last part of our Concurrency section, and

3
00:00:13,249 --> 00:00:17,693
we're going to be describing the
Half-Sync/Half-Async Pattern,

4
00:00:17,693 --> 00:00:21,300
and explaining how this gets applied in
Android.

5
00:00:21,300 --> 00:00:23,790
So, what we're going to start out by doing

6
00:00:23,790 --> 00:00:25,750
first, and you'll see I've changed the
format of my

7
00:00:25,750 --> 00:00:28,270
slides a little bit, as I think about how
I'm

8
00:00:28,270 --> 00:00:31,270
going to film these things eventually for
the Coursera Class.

9
00:00:31,270 --> 00:00:32,780
I'm trying to keep each of the modules

10
00:00:32,780 --> 00:00:35,190
down to about 20 minutes, and this stuff
is

11
00:00:35,190 --> 00:00:38,210
starting to get about an hour long, so I
split it up into a couple of parts.

12
00:00:38,210 --> 00:00:39,870
So we're first going to start off by

13
00:00:39,870 --> 00:00:43,930
talking about what the
Half-Sync/Half-Async pattern is, and then

14
00:00:43,930 --> 00:00:45,540
we're going to talk about how you would
implement

15
00:00:45,540 --> 00:00:47,950
it, and apply it in the context of
Android.

16
00:00:47,950 --> 00:00:50,000
I will also, as we discuss the pattern,
I'll

17
00:00:50,000 --> 00:00:53,180
use Android as the running example to
motivate this.

18
00:00:53,180 --> 00:00:55,550
But a lot of what I'll talk about is not
specific

19
00:00:55,550 --> 00:00:58,620
to Android, which of course is the entire
point of patterns.

20
00:00:58,620 --> 00:01:02,003
We use them to help see the generality and
design solutions, and the fact that

21
00:01:02,003 --> 00:01:05,610
we're going to learn how they apply in
Android is kind of icing on the cake.

22
00:01:05,610 --> 00:01:07,540
But what's important are the general
concepts.

23
00:01:08,540 --> 00:01:11,490
So here's the context for this discussion.

24
00:01:11,490 --> 00:01:16,307
So you often have concurrent systems that
have to perform both Synchronous

25
00:01:16,307 --> 00:01:19,690
and Asynchronous communication, and these
things

26
00:01:19,690 --> 00:01:21,390
have to communicate with each other
somehow.

27
00:01:22,410 --> 00:01:25,740
So a good example of this and, and you're
got a

28
00:01:25,740 --> 00:01:28,010
little taste of it now, and we're going to
do more

29
00:01:28,010 --> 00:01:30,520
of it as we move along, is this kind of
threaded

30
00:01:30,520 --> 00:01:32,730
download activity, or this threaded

31
00:01:32,730 --> 00:01:34,950
download application that we're working
on.

32
00:01:34,950 --> 00:01:37,500
So you've got some parts of the code that

33
00:01:37,500 --> 00:01:40,718
are going to be interacting with the user,
by the,

34
00:01:40,718 --> 00:01:43,850
the activity part, by the, the widgets and
so on,

35
00:01:43,850 --> 00:01:46,180
and some other part that's going to do
some downloading.

36
00:01:46,180 --> 00:01:49,435
So you have two different parts of the
code, at least two different parts.

37
00:01:49,435 --> 00:01:52,480
Now if you think about it, when you
actually do the downloading

38
00:01:52,480 --> 00:01:57,192
part, which is what you guys concentrated
on for this last assignment.

39
00:01:57,192 --> 00:01:58,969
You're going to write some code that's
going

40
00:01:58,969 --> 00:02:01,100
to end up blocking for some period of
time.

41
00:02:01,100 --> 00:02:04,490
And that period of time, of course, is
going to be a function of a couple things.

42
00:02:04,490 --> 00:02:06,310
It's going to be a function of how big the
file is

43
00:02:06,310 --> 00:02:09,660
you're trying to download, and it's also
going to be a function of

44
00:02:09,660 --> 00:02:12,580
things like how slow the network is, or
how fast the network

45
00:02:12,580 --> 00:02:15,990
is, how loaded your computer is, and so on
and so forth.

46
00:02:15,990 --> 00:02:19,690
So, you have to prepare yourself to avoid
the

47
00:02:19,690 --> 00:02:25,228
dreaded application not responding
exception in dialogue that you'd have.

48
00:02:25,228 --> 00:02:29,384
You have to prepare yourself to allow each
thread that's downloading to block.

49
00:02:29,384 --> 00:02:32,837
Now again, there other ways of doing this,
but for this particular example we

50
00:02:32,837 --> 00:02:35,890
want to be able to make it possible to
have the download thread block.

51
00:02:37,030 --> 00:02:38,890
And for that, to be able to have

52
00:02:38,890 --> 00:02:41,480
the simplicity of synchronization, we
don't want to have

53
00:02:41,480 --> 00:02:44,370
to require the code to know a lot

54
00:02:44,370 --> 00:02:47,560
about the more complicated interactions
with the asynchronous part.

55
00:02:47,560 --> 00:02:48,720
because this code should be simple,

56
00:02:48,720 --> 00:02:50,880
straightforward, easy to write, easy to
understand.

57
00:02:52,480 --> 00:02:53,850
We also want to be able to allow

58
00:02:53,850 --> 00:02:56,760
these Synchronous and Asynchronous
portions of the software

59
00:02:56,760 --> 00:03:00,270
to be able to run efficiently and
correctly,

60
00:03:00,270 --> 00:03:03,100
without making it too hard to program,
number one.

61
00:03:03,100 --> 00:03:05,720
And number two, without having to require
the software

62
00:03:05,720 --> 00:03:09,914
to be very inefficient from a scalability
point of view.

63
00:03:09,914 --> 00:03:13,312
For example, what we're going to end up
doing here, is were going to have a user

64
00:03:13,312 --> 00:03:15,445
thread, and then we're going to have
background

65
00:03:15,445 --> 00:03:18,150
threads that are actually going to do the
work.

66
00:03:18,150 --> 00:03:22,448
Now think about what you did for your
implementation, the way you wrote it.

67
00:03:22,448 --> 00:03:25,661
What you did in your implementation for
now for

68
00:03:25,661 --> 00:03:29,566
the, the runnable stuff, and for the, the
messages stuff.

69
00:03:29,566 --> 00:03:31,393
Is every time a user wanted to download

70
00:03:31,393 --> 00:03:33,676
something, you went ahead and just kicked
off a

71
00:03:33,676 --> 00:03:35,788
thread, and that thread was spawned kind
of

72
00:03:35,788 --> 00:03:38,230
on-demand as a sort of thread per request
model.

73
00:03:38,230 --> 00:03:40,980
Now, you know, depending on how you do
your user interface, it

74
00:03:40,980 --> 00:03:45,120
would take people pushing buttons really
fast to, to cause a problem.

75
00:03:45,120 --> 00:03:47,762
But you can imagine a scenario where you
would launch lots and lots

76
00:03:47,762 --> 00:03:51,140
and lots of threads, you have an unbound
number of threads being launched.

77
00:03:51,140 --> 00:03:53,420
And eventually those threads start to cost
you something,

78
00:03:53,420 --> 00:03:56,980
in terms of run time resources on your
device.

79
00:03:56,980 --> 00:04:01,060
So you might not want to just let
unbridled use

80
00:04:01,060 --> 00:04:02,819
of threading to be the way that you do
things.

81
00:04:04,120 --> 00:04:06,100
So what we're going to do to address this,

82
00:04:06,100 --> 00:04:10,210
is we're going to decompose the software
into two layers.

83
00:04:10,210 --> 00:04:12,310
Now sometimes you even leave these as
layers, sometimes you just

84
00:04:12,310 --> 00:04:13,540
think of them as two different

85
00:04:13,540 --> 00:04:16,260
partitionings of the software solution
space.

86
00:04:16,260 --> 00:04:20,190
And one part of the software's going to be
used to handle the Asynchronous

87
00:04:20,190 --> 00:04:23,590
part, and the other part's going to be
used to handle the Synchronous part.

88
00:04:23,590 --> 00:04:25,339
So you can see here for example in our

89
00:04:25,339 --> 00:04:27,906
context of Android, the part that's doing
the user

90
00:04:27,906 --> 00:04:30,999
interface interactions, is going to be
listening and waiting

91
00:04:30,999 --> 00:04:33,295
for, for data to show up from various
things.

92
00:04:33,295 --> 00:04:37,847
Like from a looper, or from people doing
touch events, or other kinds of

93
00:04:37,847 --> 00:04:41,059
interactions you might have through
various kinds

94
00:04:41,059 --> 00:04:44,672
of interface modalities, and those are
Asynchronous.

95
00:04:44,672 --> 00:04:46,888
And they're Asynchronous in the sense that
we're

96
00:04:46,888 --> 00:04:48,880
not really going to block while they run.

97
00:04:48,880 --> 00:04:50,805
They, they need to run in a way that
doesn't block.

98
00:04:50,805 --> 00:04:53,780
Non-blocking might be better term than
Asynchronous, but the point is

99
00:04:53,780 --> 00:04:56,680
that they don't, you don't want to block
that thread of control.

100
00:04:56,680 --> 00:04:59,428
And then we're going to have a bounded
number

101
00:04:59,428 --> 00:05:02,537
of threads that are going to run in the
background,

102
00:05:02,537 --> 00:05:05,429
and they're going to be given the actual
work to

103
00:05:05,429 --> 00:05:08,492
do from the one thread in the user
interface part.

104
00:05:08,492 --> 00:05:11,080
And then those background threads are
going to go ahead and do the processing.

105
00:05:11,080 --> 00:05:15,573
And they're going to download the file,
and then report the results back

106
00:05:15,573 --> 00:05:20,880
when they're finished, or any incremental
progress that may occur, along the way.

107
00:05:20,880 --> 00:05:22,480
And to mediate the interaction, the

108
00:05:22,480 --> 00:05:24,530
communication between the Async part and
the

109
00:05:24,530 --> 00:05:29,050
Sync part, we're going to define a queuing
layer that sits in the middle.

110
00:05:29,050 --> 00:05:31,260
Now there's a whole bunch of different
ways to do this

111
00:05:31,260 --> 00:05:33,026
queuing layer, and we're going to look at
a couple of them.

112
00:05:33,026 --> 00:05:34,690
We're going to look at a particular way of
doing

113
00:05:34,690 --> 00:05:39,100
it in the context of the Async task
framework in Android.

114
00:05:39,100 --> 00:05:41,570
But be aware, there's lots of other ways
to do this as well.

115
00:05:41,570 --> 00:05:42,910
And when we talk about the known uses

116
00:05:42,910 --> 00:05:44,700
of this pattern, you'll see that there's
many other

117
00:05:44,700 --> 00:05:47,020
ways to implement this pattern that have
different

118
00:05:47,020 --> 00:05:50,560
arrangements of queues and different parts
of the software.

119
00:05:50,560 --> 00:05:53,660
Okay, so that's, that's essentially how
we're going to structure the solution.

120
00:05:53,660 --> 00:05:56,180
In fact, that's essentially how Android
structures the solution

121
00:05:56,180 --> 00:05:57,359
for some of the things we're going to talk
about.

122
00:05:58,880 --> 00:06:01,080
So let's talk about this first as a
pattern.

123
00:06:01,080 --> 00:06:03,070
And I guess what I should point out here,
and

124
00:06:03,070 --> 00:06:08,190
let me just draw this to, to draw
attention to it.

125
00:06:08,190 --> 00:06:11,340
This interaction that we're going to see
here, is actually the

126
00:06:11,340 --> 00:06:13,520
Async Task framework, so that's how

127
00:06:13,520 --> 00:06:15,160
Android actually solved this particular
problem.

128
00:06:16,780 --> 00:06:19,735
So the, the pattern that is used to
document the way

129
00:06:19,735 --> 00:06:22,144
in which these different pieces interact

130
00:06:22,144 --> 00:06:25,480
with each other, is called
Half-Sync/Half-Async.

131
00:06:25,480 --> 00:06:28,760
It's a POSA2 Concurrency pattern.

132
00:06:28,760 --> 00:06:31,050
And the intent of this pattern is to
decouple

133
00:06:31,050 --> 00:06:35,160
the Asynchronous, or Async portions of the
software from the

134
00:06:35,160 --> 00:06:39,490
Synchronous, or Sync portions of the
software, by introducing

135
00:06:39,490 --> 00:06:44,250
two intercommunicating layers, the Async
part and the Sync part.

136
00:06:44,250 --> 00:06:46,925
And that allow, is going to allow us to be

137
00:06:46,925 --> 00:06:51,820
able to simplify the programming without
throwing performance out the window.

138
00:06:51,820 --> 00:06:54,488
because we're not going to end up trying
to spawn a thread for every piece of work.

139
00:06:54,488 --> 00:06:57,550
We're going to spawn a pool of threads,
and then

140
00:06:57,550 --> 00:07:01,030
use a queue to mediate access to that pool
of threads.

141
00:07:01,030 --> 00:07:02,690
So that's how the pattern works, and we'll

142
00:07:02,690 --> 00:07:05,350
talk later about, we'll talk shortly about
lots

143
00:07:05,350 --> 00:07:07,580
of different known uses of this pattern,
as

144
00:07:07,580 --> 00:07:09,840
it's applied to lots of things including
Android.

145
00:07:11,063 --> 00:07:13,045
And if you take a look here, this is in
the POSA2

146
00:07:13,045 --> 00:07:15,640
book, it's also in this paper that you can
get at my website.

147
00:07:16,980 --> 00:07:19,150
So when would you apply a pattern like
this?

148
00:07:19,150 --> 00:07:22,132
And as we talk through the applicability,
let's kind of relate it back to

149
00:07:22,132 --> 00:07:26,250
what's going on in, in Android just to
make this discussion a bit more concrete.

150
00:07:26,250 --> 00:07:29,570
So we want to be able to make performance
efficient and scalable.

151
00:07:29,570 --> 00:07:31,620
But we also want to make sure that using

152
00:07:31,620 --> 00:07:35,508
Concurrency simplifies our lives, as
opposed to complicating them more.

153
00:07:35,508 --> 00:07:38,310
We really don't want the application
developers to have to

154
00:07:38,310 --> 00:07:41,580
know about locking, for example, that
should be hidden from them.

155
00:07:41,580 --> 00:07:44,610
We don't want to have the application
developers know about queueing

156
00:07:44,610 --> 00:07:48,420
of messages on synchronized queues, that
should be hidden from them.

157
00:07:48,420 --> 00:07:49,930
We don't want the application developers
to know

158
00:07:49,930 --> 00:07:52,380
about spawning threads, that should be
hidden from them.

159
00:07:52,380 --> 00:07:53,610
So we're trying to hide all

160
00:07:53,610 --> 00:07:57,520
the complexities, the lower level
accidental complexities

161
00:07:57,520 --> 00:08:00,830
of programming Concurrency, and we're
actually trying

162
00:08:00,830 --> 00:08:02,780
to hide some of the inherit complexities.

163
00:08:02,780 --> 00:08:06,440
We're trying to hide the scheduling, we're
trying to hide the synchronization.

164
00:08:06,440 --> 00:08:10,450
Maybe even dealing with some deadlock
issues here, and so on and so forth.

165
00:08:10,450 --> 00:08:13,010
We're trying to make those things as
transparent as possible for the

166
00:08:13,010 --> 00:08:14,721
developers, so they don't have to worry
about that kind of stuff.

167
00:08:16,660 --> 00:08:21,480
We also apply this pattern where there are
different kinds of operations,

168
00:08:21,480 --> 00:08:25,160
that need to be able to run in different
ways and different contexts.

169
00:08:25,160 --> 00:08:27,790
So you might have short duration
operations that don't

170
00:08:27,790 --> 00:08:30,400
run for very long, like adding two numbers
together.

171
00:08:30,400 --> 00:08:33,540
It might be overkill to do those things
concurrently, you're not going to

172
00:08:33,540 --> 00:08:35,710
get any benefit, you might as well just go
ahead and do them.

173
00:08:35,710 --> 00:08:38,810
There's also longer running operations,
like downloading a file, or

174
00:08:38,810 --> 00:08:41,780
doing some kind of image processing, where
things may take longer.

175
00:08:41,780 --> 00:08:44,250
So, you may want to run those in their own
threads of control.

176
00:08:44,250 --> 00:08:47,470
There are also issues of blocking versus
non-blocking, and

177
00:08:47,470 --> 00:08:50,050
polling versus waiting, and all those
kinds of things.

178
00:08:50,050 --> 00:08:52,470
So there's different kinds of operations
that you may have,

179
00:08:52,470 --> 00:08:54,970
and you want to be able to partition where
those

180
00:08:54,970 --> 00:08:58,190
operations run, in a way that's easy to
understand and

181
00:08:58,190 --> 00:09:00,790
doesn't get out of control, in terms of
the complexity.

182
00:09:00,790 --> 00:09:05,970
By the way, this particular pattern is
very widely applied in operating system

183
00:09:05,970 --> 00:09:08,470
kernels, as we'll see, and it's

184
00:09:08,470 --> 00:09:11,100
also widely applied in user interface
frameworks.

185
00:09:11,100 --> 00:09:12,720
And we've been talking about this quite a
bit.

186
00:09:12,720 --> 00:09:16,340
So, what I'm doing now is I'm providing
you a more fundamental

187
00:09:16,340 --> 00:09:17,670
grounding in the key roles or

188
00:09:17,670 --> 00:09:20,300
relationships of the structure of these
solutions.

189
00:09:20,300 --> 00:09:23,260
But you've already seen a lot of how this
stuff applies.

190
00:09:23,260 --> 00:09:26,580
So let's talk a bit about how you design
things according

191
00:09:26,580 --> 00:09:29,930
to this pattern, there's three layers as
you can see here.

192
00:09:29,930 --> 00:09:33,420
There's the Async Service Layer, where
you're going

193
00:09:33,420 --> 00:09:35,320
to do things that don't run for very long.

194
00:09:35,320 --> 00:09:37,800
So short running operations would
typically run

195
00:09:37,800 --> 00:09:40,820
in the Async Services Layer, and here

196
00:09:40,820 --> 00:09:43,820
you're maybe going to, you know, get some
data, do a little processing on it.

197
00:09:43,820 --> 00:09:45,940
And then when you're done with that
processing,

198
00:09:45,940 --> 00:09:48,680
which is kind of what the user interface
thread does,

199
00:09:48,680 --> 00:09:55,190
then you go ahead and you, you offer it,
you put it into some kind of queue.

200
00:09:55,190 --> 00:09:58,810
And 99 times out of 100, or probably
99.999% of the

201
00:09:58,810 --> 00:10:02,510
times out of 100, that queue is a so
called Synchronized queue.

202
00:10:02,510 --> 00:10:04,610
So all of the stuff we've been talking
about

203
00:10:04,610 --> 00:10:08,150
with regard to monitor objects, and
bounded buffers, and buffer

204
00:10:08,150 --> 00:10:10,530
queues and blocking queues, and all that
kind of stuff,

205
00:10:10,530 --> 00:10:12,160
that's the kind of queue that we're
talking about here.

206
00:10:12,160 --> 00:10:15,000
So the queue here would be something like
the Android message

207
00:10:15,000 --> 00:10:17,645
queue, or the blocking queue, or other
kinds of queues like that.

208
00:10:19,130 --> 00:10:21,270
And then there'll be some number of
threads

209
00:10:21,270 --> 00:10:24,160
that wait in a pool, in so-called a hungry

210
00:10:24,160 --> 00:10:27,130
puppy fashion, because they're all waiting
to receive work

211
00:10:27,130 --> 00:10:31,200
requests from the the Async part of the
world.

212
00:10:31,200 --> 00:10:33,780
And they pull the requests out, and then
they go ahead and process

213
00:10:33,780 --> 00:10:36,100
those requests, and because there are
separate

214
00:10:36,100 --> 00:10:39,090
threads, they can afford to block
independently.

215
00:10:39,090 --> 00:10:40,600
And if one of them blocks, not a

216
00:10:40,600 --> 00:10:43,110
problem, somebody else can continue to
make progress.

217
00:10:44,205 --> 00:10:46,620
Okay, so that's essentially the structure
of the solution.

218
00:10:46,620 --> 00:10:49,610
And hopefully you can kind of see how this
maps onto the parts of Android.

219
00:10:49,610 --> 00:10:53,070
And we'll come back later when we get a
little further along

220
00:10:53,070 --> 00:10:55,510
in the discussion here, and we'll show you
how it works in Android.

221
00:10:56,640 --> 00:10:59,840
Alright here's sort of a dynamic view of
what's happening here,

222
00:10:59,840 --> 00:11:02,130
is to give you another flavor of what is
happening, so we

223
00:11:02,130 --> 00:11:05,430
get the structural part that illustrates
the key three layers, and now

224
00:11:05,430 --> 00:11:08,040
we're going to talk about the dynamics,
how they interact with each other.

225
00:11:08,040 --> 00:11:12,540
So, we start out with data coming in from
somewhere in the case of

226
00:11:12,540 --> 00:11:14,640
say an operating system kernel that
somewhere's

227
00:11:14,640 --> 00:11:18,050
typically a device interrupt from a
hardware device.

228
00:11:18,050 --> 00:11:20,590
In the case of something like Android,
that, that

229
00:11:20,590 --> 00:11:23,910
input is coming in from some device
hardware, but

230
00:11:23,910 --> 00:11:25,990
it's been abstracted by a bit, and it's
coming

231
00:11:25,990 --> 00:11:29,060
into your application process, probably
through the event loop.

232
00:11:29,060 --> 00:11:32,470
And the event queue that's managed by the
looper, we'll

233
00:11:32,470 --> 00:11:35,050
look at that when we get to the
implementation portion.

234
00:11:35,050 --> 00:11:37,180
However it gets in, you finally get the
data,

235
00:11:37,180 --> 00:11:38,780
and you do a little bit of work on it.

236
00:11:38,780 --> 00:11:40,270
In the case, for example, in your
programming

237
00:11:40,270 --> 00:11:43,020
assignment, you might of done some URL
validation.

238
00:11:43,020 --> 00:11:45,400
Might of said, is this URL valid or not?

239
00:11:45,400 --> 00:11:46,110
Small amount of work.

240
00:11:46,110 --> 00:11:49,958
And then you're going to go ahead at least
in the case of the Async task, and you're

241
00:11:49,958 --> 00:11:52,350
going to say something like execute, or
you're going

242
00:11:52,350 --> 00:11:54,940
to pass it, you're going to stick it
someplace.

243
00:11:54,940 --> 00:11:58,090
And that will end up in queuing the work,
on

244
00:11:58,090 --> 00:12:01,580
to a queue without blocking the caller,
and that's really important.

245
00:12:01,580 --> 00:12:04,730
You have to make a decision about whether
you block the caller or not.

246
00:12:04,730 --> 00:12:06,400
If the queue is full what do you do?

247
00:12:06,400 --> 00:12:07,490
Do you fail?

248
00:12:07,490 --> 00:12:08,040
Do you block?

249
00:12:08,040 --> 00:12:08,590
Do you wait?

250
00:12:08,590 --> 00:12:10,370
Do you wait for a period of time?

251
00:12:10,370 --> 00:12:12,590
Those are all part of the implementation
decisions

252
00:12:12,590 --> 00:12:14,500
you would make, if you were implementing
this pattern.

253
00:12:14,500 --> 00:12:15,266
And we'll talk more about that.

254
00:12:15,266 --> 00:12:20,390
And then somehow one of the other threads
that's running in the

255
00:12:20,390 --> 00:12:23,830
background is going to learn about the
existence of the work in the queue.

256
00:12:23,830 --> 00:12:28,040
And that's probably because whenever that
thread isn't doing anything, it's going to

257
00:12:28,040 --> 00:12:31,220
go back and wait for work to show up in
the blocking queue.

258
00:12:31,220 --> 00:12:33,330
And when work shows up, it'll pull it out

259
00:12:33,330 --> 00:12:35,804
of the queue, and it'll go ahead and
process it.

260
00:12:35,804 --> 00:12:40,100
And that request since it is running in
it's own thread of control, can afford to

261
00:12:40,100 --> 00:12:42,770
run and block because they're other
threads in

262
00:12:42,770 --> 00:12:45,550
the pool that are also able to do work.

263
00:12:45,550 --> 00:12:47,870
Now this begs a whole bunch of interesting
questions, and when we

264
00:12:47,870 --> 00:12:51,300
talk more about the implementation, you'll
see that in Java, they do

265
00:12:51,300 --> 00:12:55,320
some really, really cool things under the
hood, as part of the

266
00:12:55,320 --> 00:12:56,900
executor framework and the thread pull

267
00:12:56,900 --> 00:12:59,550
executor framework to handle all this
stuff.

268
00:12:59,550 --> 00:13:01,790
But in general, you've got a bunch of
different degrees of

269
00:13:01,790 --> 00:13:03,800
freedom to play with here and I'll talk
about them later.

270
00:13:03,800 --> 00:13:07,050
But real quickly, you have to figure out
how many threads you want

271
00:13:07,050 --> 00:13:10,930
to allocate to be part of this pool, and
are they bounded or unbounded?

272
00:13:10,930 --> 00:13:13,326
Can you keep spawning threads galore?

273
00:13:13,326 --> 00:13:14,911
The more threads you spawn, the less it's

274
00:13:14,911 --> 00:13:17,160
a pool, and more it's just thread for
request.

275
00:13:17,160 --> 00:13:19,000
Then you also have the concept of the
queue.

276
00:13:19,000 --> 00:13:19,770
How big is the queue?

277
00:13:19,770 --> 00:13:22,890
Is the queue a fixed size, is it unbounded
size?

278
00:13:22,890 --> 00:13:25,430
And, and obviously there's, there's a
trade off here.

279
00:13:25,430 --> 00:13:29,070
Because if you're not careful you could
end up allocating way, way, way too much

280
00:13:29,070 --> 00:13:31,940
resources, too many resources, and your
other

281
00:13:31,940 --> 00:13:33,399
things will start to suffer as a result.

282
00:13:34,930 --> 00:13:38,470
Okay, so keep in mind here that the
Synchronous services run concurrently,

283
00:13:38,470 --> 00:13:41,890
both with respect to each other, and also
to the Asynchronous part.

284
00:13:41,890 --> 00:13:47,240
So what that suggests is that the parts in
the Asynchronous portion, and the parts

285
00:13:47,240 --> 00:13:49,330
in the Synchronous portion, should be
very,

286
00:13:49,330 --> 00:13:52,110
very careful how they interact with each
other.

287
00:13:52,110 --> 00:13:54,730
For example, they, they probably should be
extremely

288
00:13:54,730 --> 00:13:59,550
careful not to try to access shared state
directly.

289
00:13:59,550 --> 00:14:01,840
Because, if they do that, they either need
to lock it, which

290
00:14:01,840 --> 00:14:05,980
could then run into problems, or they'll
end up with race conditions.

291
00:14:05,980 --> 00:14:09,000
So, it's, it's often the case that things
in the Async layer, and

292
00:14:09,000 --> 00:14:13,840
things at the Sync layer communicate
purely by passing messages back and forth.

293
00:14:13,840 --> 00:14:15,879
And you'll get a bit more of a flavor of
that

294
00:14:15,879 --> 00:14:18,202
when we take a look at how the Async task
framework

295
00:14:18,202 --> 00:14:21,375
behaves, because that's kind of how it
works, it's hidden from

296
00:14:21,375 --> 00:14:24,400
you by and large, but that's what it's
doing under the hood.

297
00:14:24,400 --> 00:14:26,398
Okay, so, what I've been doing in the past
at

298
00:14:26,398 --> 00:14:29,700
this point, is I've been showing the
implementation and applicability.

299
00:14:29,700 --> 00:14:33,332
I'm going to defer that discussion, and
we're going to cover that next.

300
00:14:33,332 --> 00:14:34,180
What I want to do now is sort

301
00:14:34,180 --> 00:14:37,350
of talk about the consequences of applying
this pattern.

302
00:14:37,350 --> 00:14:40,210
So here's a couple things to think about.

303
00:14:40,210 --> 00:14:41,679
We, we've talked about a number of
patterns so

304
00:14:41,679 --> 00:14:43,233
far, and this is actually a great quiz
question.

305
00:14:43,233 --> 00:14:47,060
So, we've talked about thread specific
storage.

306
00:14:47,060 --> 00:14:49,756
We've talked about monitor object, we've
talked about active

307
00:14:49,756 --> 00:14:52,763
object, and now we`re introducing yet
another Concurrency pattern.

308
00:14:52,763 --> 00:14:54,919
So these are a bunch of different
patterns.

309
00:14:54,919 --> 00:14:56,919
You can argue that thread specific storage
is really

310
00:14:56,919 --> 00:14:59,382
more of a Synchronization pattern than a
Concurrency pattern.

311
00:14:59,382 --> 00:15:00,010
That's fine.

312
00:15:00,010 --> 00:15:01,518
But we've got a bunch of different

313
00:15:01,518 --> 00:15:04,750
ways of accessing information in
multithreaded programs.

314
00:15:04,750 --> 00:15:08,390
And so, its important to understand the
pros and cons of each one.

315
00:15:08,390 --> 00:15:10,970
Why would you choose to use one versus
another.

316
00:15:10,970 --> 00:15:12,380
And this shows up in all kinds of
different

317
00:15:12,380 --> 00:15:15,090
ways when you start designing your android
code, for example.

318
00:15:15,090 --> 00:15:17,990
Because when you start designing your
android code, you have to make a choice.

319
00:15:17,990 --> 00:15:23,380
Do I use the handlers and messages idiom,
which you did.

320
00:15:23,380 --> 00:15:26,790
Do I use the handlers and runnerables
idiom, do I use

321
00:15:26,790 --> 00:15:29,490
the async task idiom, which is the right
one to use?

322
00:15:29,490 --> 00:15:31,920
And of course there's no one right answer,
it

323
00:15:31,920 --> 00:15:33,520
all depends largely on what you're trying
to do.

324
00:15:33,520 --> 00:15:37,020
So we'll talk more about tradeoffs between
the different approaches here in a second.

325
00:15:37,020 --> 00:15:39,690
But first let's talk more about the
consequences of this.

326
00:15:39,690 --> 00:15:42,460
So the basic idea is to simplify

327
00:15:42,460 --> 00:15:45,220
things without throwing performance out
the window.

328
00:15:45,220 --> 00:15:46,790
And what I mean by that is we, we don't

329
00:15:46,790 --> 00:15:49,370
want to let the threads grow in an
unbounded way.

330
00:15:49,370 --> 00:15:51,270
We don't want to make the whole program
threaded.

331
00:15:51,270 --> 00:15:54,460
We don't want to have to make the GUI
thread for example.

332
00:15:54,460 --> 00:15:56,390
The UI thread have to acquire lots to

333
00:15:56,390 --> 00:16:00,550
do things that manipulate widgets of
various kinds.

334
00:16:00,550 --> 00:16:02,060
We want to keep that real simple.

335
00:16:02,060 --> 00:16:03,690
And, and efficient.

336
00:16:03,690 --> 00:16:07,280
So, what we're doing there is we're
keeping the sync layer separate

337
00:16:07,280 --> 00:16:10,730
from the async layer so that they can be
programmed in different ways.

338
00:16:10,730 --> 00:16:13,890
Each for their own respective idiom.

339
00:16:13,890 --> 00:16:16,362
Anybody here is a Monty Python fan,
there's

340
00:16:16,362 --> 00:16:19,558
a bit on Monty Python about someone's
particular idiom.

341
00:16:19,558 --> 00:16:21,290
I will look at this diagram a little bit
later.

342
00:16:21,290 --> 00:16:23,540
This is kind of showing how the async

343
00:16:23,540 --> 00:16:27,933
task framework behaves [SOUND] to these
different capabilities.

344
00:16:27,933 --> 00:16:30,698
Another key issue here is separation
concerns, so

345
00:16:30,698 --> 00:16:33,851
the synchronization policies in each layer
decouple from

346
00:16:33,851 --> 00:16:38,351
each other in the, in the layer that's the
async layer, there is really no need for

347
00:16:38,351 --> 00:16:41,051
synchronization as long as you're careful
not to

348
00:16:41,051 --> 00:16:43,945
access any variables that are going to be
manipulated

349
00:16:43,945 --> 00:16:46,321
by some other thread, so you, you just

350
00:16:46,321 --> 00:16:49,740
take that problem out of the equation all
together.

351
00:16:49,740 --> 00:16:52,042
In the sync layer, again, if you access

352
00:16:52,042 --> 00:16:54,495
things you have to make sure you lock
them.

353
00:16:54,495 --> 00:16:57,300
And it's possible to lock them because you
can block in that layer.

354
00:16:57,300 --> 00:17:00,150
So there's different kinds of policies in
different layers.

355
00:17:00,150 --> 00:17:02,429
And you don't have to have the same
behavior used in each place.

356
00:17:03,620 --> 00:17:04,560
When we start taking a look at how

357
00:17:04,560 --> 00:17:07,870
this pattern gets applied in more unusual
environments,

358
00:17:07,870 --> 00:17:09,370
things that you are unlikely to ever run

359
00:17:09,370 --> 00:17:13,110
across unless you become a systems
programmer somehow.

360
00:17:13,110 --> 00:17:15,330
For operating systems, you'll see that
when people

361
00:17:15,330 --> 00:17:17,900
program operating system kernels, there's
a very different

362
00:17:17,900 --> 00:17:20,590
set of locking mechanisms that are used
inside

363
00:17:20,590 --> 00:17:23,760
the kernel then there are in the user
space.

364
00:17:23,760 --> 00:17:25,210
And that's because often in the Kernel
level,

365
00:17:25,210 --> 00:17:27,260
you're dealing with things like hardware
interrupts, and

366
00:17:27,260 --> 00:17:29,070
you have to be much more concerned about

367
00:17:29,070 --> 00:17:31,720
interruptions and a-synchrony, and
signals, and so on.

368
00:17:31,720 --> 00:17:32,840
Where as in the user level, it's

369
00:17:32,840 --> 00:17:35,190
a simple little program, from an
application perspective.

370
00:17:37,150 --> 00:17:39,640
Another thing you get, in this model, and
you see this

371
00:17:39,640 --> 00:17:42,490
when you start playing around with the
android, it's very pronounced.

372
00:17:42,490 --> 00:17:46,450
You can have this, sort of centralization
of communication between things.

373
00:17:46,450 --> 00:17:50,100
You funnel, you often funnel stuff through
a particular

374
00:17:50,100 --> 00:17:52,940
handle, or a particular handler with a
particular message queue.

375
00:17:52,940 --> 00:17:55,900
For example, if you want to get work into
the

376
00:17:55,900 --> 00:17:58,030
UI thread there's well other fine ways to
do that.

377
00:17:58,030 --> 00:18:00,712
You do things like run on UI thread,

378
00:18:00,712 --> 00:18:03,520
you, you pass things and that ends up
guaranteed

379
00:18:03,520 --> 00:18:07,840
to come up through the main event pump
inside the UI thread to get the work done.

380
00:18:07,840 --> 00:18:10,220
So there's very stylized ways, very
centralized ways

381
00:18:10,220 --> 00:18:12,260
to talk back and forth between these
layers.

382
00:18:12,260 --> 00:18:14,700
It's not a big mystery where to go to
communicate.

383
00:18:14,700 --> 00:18:18,710
Although things are often somewhat
implicit which makes it confusing.

384
00:18:18,710 --> 00:18:23,580
So those are the good things, there are
some downsides, much like with the,

385
00:18:23,580 --> 00:18:29,400
the active object pattern implementation
that we talked about last time.

386
00:18:29,400 --> 00:18:31,590
Whenever you start to communicate between

387
00:18:31,590 --> 00:18:34,190
threads, there's going to be extra
overhead.

388
00:18:34,190 --> 00:18:36,690
That you don't have if your within one
thread.

389
00:18:36,690 --> 00:18:38,890
So for example, if you start trying to
pass messages between

390
00:18:38,890 --> 00:18:41,335
threads, your going to run into issues of
synchronization, you're going to

391
00:18:41,335 --> 00:18:42,900
run into issues of dynamic mem, memory
allocation, deallocation, you're going to

392
00:18:42,900 --> 00:18:47,360
run into issues of context switching,
you're going to run into issues of

393
00:18:50,490 --> 00:18:54,400
moving data between CPU caches, which is
more of a hardware level

394
00:18:54,400 --> 00:18:58,080
thing or bus level thing, but it still is
a thing nonetheless,

395
00:18:58,080 --> 00:19:00,580
and you know for people who really care
about that kind of

396
00:19:00,580 --> 00:19:05,580
stuff that's crucially important to eking
out every last nanosecond of performance.

397
00:19:05,580 --> 00:19:08,530
A lot of the application level stuff you
might do on Android probably doesn't make

398
00:19:08,530 --> 00:19:10,790
that much difference but if you're not
careful

399
00:19:10,790 --> 00:19:12,520
you could make software that runs really
slow.

400
00:19:12,520 --> 00:19:16,430
So there is overhead here you just have to
be aware of it and you have

401
00:19:16,430 --> 00:19:18,520
to think careful about what kind of
operation

402
00:19:18,520 --> 00:19:20,920
you're going to want to run in this model.

403
00:19:20,920 --> 00:19:24,080
Don't run long running operations in the
async part,

404
00:19:24,080 --> 00:19:26,220
don't run short duration operations in the
sync part.

405
00:19:26,220 --> 00:19:26,720
Its overcome.

406
00:19:28,640 --> 00:19:32,655
Another issue that we have here is that
we're only using asynchronous

407
00:19:32,655 --> 00:19:36,320
I/O for a portion of what we're doing, and
that's sort of

408
00:19:36,320 --> 00:19:39,190
the, the lower layer part, so that the
things that are in

409
00:19:39,190 --> 00:19:43,210
the sync layer might or might not be
actually benefiting from asynchrony.

410
00:19:43,210 --> 00:19:46,210
And later when we come back and talk

411
00:19:46,210 --> 00:19:49,370
in the next section about local
interprocess communication.

412
00:19:49,370 --> 00:19:52,080
We start talking about the binder and the
AIDL and

413
00:19:52,080 --> 00:19:53,750
all these higher level ways

414
00:19:53,750 --> 00:19:56,790
of communicating between processes in
Android.

415
00:19:56,790 --> 00:19:58,520
You'll see some other cool stuff we're
going to add

416
00:19:58,520 --> 00:20:01,750
there to be able to do asynchronous
interactions between various parts.

417
00:20:01,750 --> 00:20:04,610
And it's really cool, because now you can
make your entire program asynchronous.

418
00:20:04,610 --> 00:20:06,230
And that's a whole different pattern
together.

419
00:20:06,230 --> 00:20:08,889
That's more of the so-called proactive
pattern that we'll talk about.

420
00:20:10,300 --> 00:20:13,190
And again, goes without saying, anytime
you start having

421
00:20:13,190 --> 00:20:16,850
concurrent things happening, it's more
tricky to program and debug.

422
00:20:17,930 --> 00:20:19,280
The good news is that if you follow

423
00:20:19,280 --> 00:20:23,210
these very stylized frameworks, like the
async task framework.

424
00:20:23,210 --> 00:20:25,250
Then you can put break points in certain
places.

425
00:20:25,250 --> 00:20:27,210
You kind of know what's going to happen
when.

426
00:20:27,210 --> 00:20:30,120
The framework has taken care of all the
synchronization.

427
00:20:30,120 --> 00:20:32,530
For you under the hood, and so on and so
forth.

428
00:20:32,530 --> 00:20:34,090
So it makes your life as a programmer much

429
00:20:34,090 --> 00:20:35,710
easier, because you don't have to worry
about this stuff.

430
00:20:35,710 --> 00:20:38,010
If you are writing this yourself, you have
to be more careful.

431
00:20:39,370 --> 00:20:41,990
Next week at some point we'll probably
have a couple people that

432
00:20:41,990 --> 00:20:44,400
did particularly interesting solutions to
the

433
00:20:44,400 --> 00:20:46,860
latest programming assignment, present
their solutions.

434
00:20:46,860 --> 00:20:49,440
And one of the things you'll see is, is
the amount of trouble they went through,

435
00:20:49,440 --> 00:20:51,641
to make sure that the rules for their,

436
00:20:51,641 --> 00:20:55,280
their concurrency framework, that they
developed are properly followed.

437
00:20:55,280 --> 00:20:57,600
Checking to see the threads are running,
all the

438
00:20:57,600 --> 00:20:59,402
user interface threads, if that's what
their supposed to do.

439
00:20:59,402 --> 00:21:01,210
Checking to make sure that they're running
in the

440
00:21:01,210 --> 00:21:03,280
background thread, if that's what their
supposed to do.

441
00:21:03,280 --> 00:21:06,580
So, you'd like that not to have to be the
concern of the programmer.

442
00:21:06,580 --> 00:21:07,440
The application programmer.

443
00:21:07,440 --> 00:21:09,900
You want that to be concerning to the
infrastructure developer.

444
00:21:09,900 --> 00:21:11,520
The person writing.

445
00:21:11,520 --> 00:21:15,440
The async task framework for example, not
the person who's using it.

446
00:21:17,055 --> 00:21:19,380
Okay, so let's talk about some of the
known uses.

447
00:21:19,380 --> 00:21:22,960
So this pattern is actually something I

448
00:21:22,960 --> 00:21:27,280
discovered, back in 1994-95 time frame
when

449
00:21:27,280 --> 00:21:30,190
I was a professor at Washington University

450
00:21:30,190 --> 00:21:32,790
and I was teaching an operating systems
course.

451
00:21:32,790 --> 00:21:36,530
And we were talking about, how the opening
system Kernel worked.

452
00:21:36,530 --> 00:21:39,410
And at the same time, I was, I was doing a
couple things at the same time.

453
00:21:39,410 --> 00:21:42,150
I was teaching an opening system course, I
was developing

454
00:21:42,150 --> 00:21:46,070
some software that had to run in an
ex-Windows environment.

455
00:21:46,070 --> 00:21:49,500
Which had the same quirk that most user
interfaces do,

456
00:21:49,500 --> 00:21:52,820
where the main thread of control had to be
single threaded.

457
00:21:52,820 --> 00:21:56,430
The, the widget's access from the main
thread had to be single threaded.

458
00:21:56,430 --> 00:21:58,750
But we had to be able to do long running
downloads of

459
00:21:58,750 --> 00:22:01,910
images so we had to be able to do threads
as well.

460
00:22:01,910 --> 00:22:04,320
So had that going on, I was doing some
consulting

461
00:22:04,320 --> 00:22:06,210
work for some telecommunications
companies,

462
00:22:06,210 --> 00:22:08,380
where they were building switches,

463
00:22:08,380 --> 00:22:11,505
telecom switches, and I was also working
on an implementation

464
00:22:11,505 --> 00:22:15,080
of,of KORBA, and playing around with
different implementations of KORBA.

465
00:22:15,080 --> 00:22:16,590
So it was all these different things, and
as I

466
00:22:16,590 --> 00:22:18,690
was looking at all the different stuff I
was doing.

467
00:22:18,690 --> 00:22:21,260
I started to notice common themes, but the
place it

468
00:22:21,260 --> 00:22:23,920
really showed up the most was in the
operating system.

469
00:22:23,920 --> 00:22:26,740
Because if you read literature about
operating systems

470
00:22:26,740 --> 00:22:29,078
from sort of the 80's and 90's, what

471
00:22:29,078 --> 00:22:32,200
you found was that the operating system
kernel,

472
00:22:32,200 --> 00:22:34,590
was developed quite differently from the
user level.

473
00:22:34,590 --> 00:22:36,280
And if you take a look at this paper down
here you'll

474
00:22:36,280 --> 00:22:40,170
get more than you ever wanted to know
about operating system kernels.

475
00:22:40,170 --> 00:22:42,260
And what's really interesting about this
is that operating

476
00:22:42,260 --> 00:22:47,190
system kernels are typically driven by
interrupts from hardware.

477
00:22:47,190 --> 00:22:51,840
And so when networking IO shows up or when
keystrokes

478
00:22:51,840 --> 00:22:56,270
arrive or when data's transferred between
different things, you know?

479
00:22:56,270 --> 00:22:58,030
Reading or writing from a file system.

480
00:22:58,030 --> 00:22:59,020
Or what not.

481
00:22:59,020 --> 00:23:01,170
Those things turn into interrupts.

482
00:23:01,170 --> 00:23:03,120
And, the way it's programmed,
historically,

483
00:23:03,120 --> 00:23:04,360
this is changed a bit over time.

484
00:23:04,360 --> 00:23:07,050
But it's still often the case inside the
operating system Kernel.

485
00:23:07,050 --> 00:23:11,310
An awful lot of the process that takes
place there, is done by interrupts.

486
00:23:11,310 --> 00:23:14,200
And if anybody's ever programmed
interrupt, different programming, say

487
00:23:14,200 --> 00:23:16,900
in an imbedded system class, or in an
internship.

488
00:23:16,900 --> 00:23:18,930
It is really, really nasty.

489
00:23:18,930 --> 00:23:22,910
Because things sort of happen in somewhat
of random way.

490
00:23:22,910 --> 00:23:25,930
You know, when the hardware, when the,
when the thing occurs, an interrupt

491
00:23:25,930 --> 00:23:30,230
happens and you are not supposed to spend
very much time inside your

492
00:23:30,230 --> 00:23:31,650
interrupt handler cause you can starve

493
00:23:31,650 --> 00:23:33,810
out other things from getting, getting
responded

494
00:23:33,810 --> 00:23:37,190
so that you would get that mas interrupts,
why you're in a interrupt handler.

495
00:23:37,190 --> 00:23:39,270
And all the interrupts to be even more
important than

496
00:23:39,270 --> 00:23:42,840
your interrupt then whatever you're doing,
get the chance to wrap.

497
00:23:42,840 --> 00:23:47,072
So, typically, they program operating
systems kernels where there is sort of

498
00:23:47,072 --> 00:23:51,350
only one thread and one stack and
everything is driven by interrupts.

499
00:23:51,350 --> 00:23:54,450
Well if you think about it there's not a
heck of a lot you can do in that context.

500
00:23:54,450 --> 00:23:58,150
So people invented various hierarchical
interrupt schemes.

501
00:23:58,150 --> 00:24:00,110
And the long and the short of it is that
kernels are

502
00:24:00,110 --> 00:24:04,620
driven by interrupts and it's very very
complicated to program software like that.

503
00:24:04,620 --> 00:24:05,891
That's okay though because there's only

504
00:24:05,891 --> 00:24:07,850
a handful of people doing kernel
programming.

505
00:24:07,850 --> 00:24:09,470
And what they do is as soon as they
finally

506
00:24:09,470 --> 00:24:11,850
get a unit of work that's completely
finished like they

507
00:24:11,850 --> 00:24:14,830
assemble different pieces of buffers that
come in from a

508
00:24:14,830 --> 00:24:19,870
network client and they put them into one
bigger reassembled buffer.

509
00:24:19,870 --> 00:24:22,890
They then take that work and they stick it
into a queueing layer.

510
00:24:22,890 --> 00:24:26,410
And in the operating system context things
for

511
00:24:26,410 --> 00:24:29,460
UNIX kind of context that's often called a
socket layer.

512
00:24:29,460 --> 00:24:31,890
So a socket layer is basically a queuing
layer

513
00:24:31,890 --> 00:24:34,882
that's used to queue up the data that has
come

514
00:24:34,882 --> 00:24:39,040
in from hardware devices driven by
interrupts in the kernel

515
00:24:39,040 --> 00:24:42,250
to be reassembled, to be stuck under this
queue layer.

516
00:24:42,250 --> 00:24:44,700
Now hence from that point onwards, life is
happy.

517
00:24:44,700 --> 00:24:49,990
Because what happens is application level
developers run processes and

518
00:24:49,990 --> 00:24:52,690
then they have multiple threads, and they
can afford to block.

519
00:24:52,690 --> 00:24:55,500
And they can do all kinds of other
interesting things in those processes.

520
00:24:55,500 --> 00:24:58,730
In user space, and they pull the work out
of

521
00:24:58,730 --> 00:25:01,250
the, the socket queues, and then they do
their thing.

522
00:25:01,250 --> 00:25:02,650
And when they're all done they go ahead
and put it

523
00:25:02,650 --> 00:25:06,610
back in the queue and it gets sent out via
interrupts.

524
00:25:06,610 --> 00:25:07,710
So the point there is that the low

525
00:25:07,710 --> 00:25:10,410
level parts are interrupt driven, that's
the async part.

526
00:25:10,410 --> 00:25:14,340
And the higher level parts are optionally
synchronous, because

527
00:25:14,340 --> 00:25:16,690
you can afford to block, because you have
a

528
00:25:16,690 --> 00:25:19,630
process or a thread abstraction or both at
your

529
00:25:19,630 --> 00:25:22,750
discretion to keep track of all the
details for you.

530
00:25:22,750 --> 00:25:25,370
So that was pretty cool, and looking at
the way that those things work,

531
00:25:25,370 --> 00:25:29,260
we realize people broke the system up into
these different parts for a reason.

532
00:25:29,260 --> 00:25:35,860
To keep the applications shielded from the
complexities of asynchrony, but to be able

533
00:25:35,860 --> 00:25:38,610
to keep the Kernel programmers able to

534
00:25:38,610 --> 00:25:40,390
make their software as efficient as
possible.

535
00:25:40,390 --> 00:25:42,750
Because it doesn't really, do you much
good to have lots and lots and

536
00:25:42,750 --> 00:25:43,940
lots of threads running around on the

537
00:25:43,940 --> 00:25:46,070
Kernel because those make things really
slow.

538
00:25:46,070 --> 00:25:47,120
And so that's one example.

539
00:25:47,120 --> 00:25:51,640
Great example if you ever end up looking
inside things like BSD Unix which is

540
00:25:51,640 --> 00:25:53,630
all open source or Linux, you'll, you'll

541
00:25:53,630 --> 00:25:55,890
get a lot out of understanding that
pattern.

542
00:25:55,890 --> 00:26:00,210
There's also patterns that show up a lot
in middle wear, things like

543
00:26:00,210 --> 00:26:03,390
Korba where they do much the same thing,
you have some kind of

544
00:26:03,390 --> 00:26:06,060
layer at the bottom that waits on a lot of
different sources of

545
00:26:06,060 --> 00:26:10,690
input to get data from sockets, that's the
async part or the reactive part.

546
00:26:10,690 --> 00:26:13,920
And then those things give the data off
into various queues.

547
00:26:13,920 --> 00:26:15,510
Either one queue or multiple queues.

548
00:26:15,510 --> 00:26:17,010
And then there are threads running in
those

549
00:26:17,010 --> 00:26:19,020
queues to do the processing, that's
another example.

550
00:26:20,220 --> 00:26:23,710
And then we have the Android Async Task
framework.

551
00:26:23,710 --> 00:26:26,554
And we'll take a look in, in more detail
in

552
00:26:26,554 --> 00:26:30,425
a second [NOISE] excuse me at the Async
Task framework.

553
00:26:30,425 --> 00:26:34,140
And you'll see how and why that gets used
and

554
00:26:34,140 --> 00:26:38,470
what that does to, to be a win in this
context.

555
00:26:38,470 --> 00:26:42,328
Okay, so those are a bunch of different
known uses of the pattern.

556
00:26:42,328 --> 00:26:46,178
This is one of my favorite patterns from
the POSA2 book because it's so powerful,

557
00:26:46,178 --> 00:26:49,540
and you see it show up in the most unusual
places, as we're about to see.

558
00:26:50,810 --> 00:26:51,130
Alright.

559
00:26:51,130 --> 00:26:53,310
So to summarize, the half-sync, half-async

560
00:26:53,310 --> 00:26:56,010
works to simplify your solutions, by
breaking

561
00:26:56,010 --> 00:27:00,440
it up into three layers which makes things
easier to debug, evolve, understand.

562
00:27:01,480 --> 00:27:03,320
We don't force people to asynchronous

563
00:27:03,320 --> 00:27:05,230
stuff, where synchronous stuff makes
sense.

564
00:27:05,230 --> 00:27:05,910
We don't force people to do

565
00:27:05,910 --> 00:27:08,040
synchronous stuff, where asynchronous
stuff makes sense.

566
00:27:08,040 --> 00:27:09,769
Everything is done where it belongs.

567
00:27:10,776 --> 00:27:17,330
And the queuing layer makes it possible to
avoid directly accessing

568
00:27:17,330 --> 00:27:20,830
state, instead you can pass it back and
forth in a queue.

569
00:27:20,830 --> 00:27:23,331
Another cool thing, by the way, that comes
from

570
00:27:23,331 --> 00:27:26,140
having a, a queue is you can re-prioritize
the work.

571
00:27:26,140 --> 00:27:28,270
So the order in which things are processed
is not the same

572
00:27:28,270 --> 00:27:32,060
order in which they have to have been
received in the first place.

573
00:27:32,060 --> 00:27:35,980
That's not unlike the, the active object
pattern.

574
00:27:35,980 --> 00:27:43,360
In fact, one not uncommon way of doing
this stuff is actually to put the

575
00:27:43,360 --> 00:27:47,150
active object pattern on top, connected
with another pattern called a reactor.

576
00:27:47,150 --> 00:27:49,530
We'll probably talk about reactors later
when we talk about

577
00:27:49,530 --> 00:27:52,400
some of the lower level parts of, of Java
IO.

578
00:27:54,340 --> 00:27:54,640
Alright.

579
00:27:54,640 --> 00:27:56,940
So that's the end of the overview of the
pattern part.

580
00:27:56,940 --> 00:28:00,110
With just enough discussion of Android to
connect it back to the class.

581
00:28:00,110 --> 00:28:03,770
But keep in mind that this pattern really
is not at all beholden to Android.

582
00:28:03,770 --> 00:28:04,940
We're just using it as an illustration.

583
00:28:06,480 --> 00:28:08,020
What I'd like to do now in the rest of the

584
00:28:08,020 --> 00:28:10,989
talk is show you how this actually gets
implemented in Android.

585
00:28:12,420 --> 00:28:15,460
And so we're going to understand how to
implement the

586
00:28:15,460 --> 00:28:20,500
pattern in general using Android as
examples of how it's implemented.

587
00:28:20,500 --> 00:28:22,290
And then we're also going to look and see

588
00:28:22,290 --> 00:28:24,730
how it, you can apply this pattern in
Android.

589
00:28:24,730 --> 00:28:26,680
And the context for this whole discussion
is

590
00:28:26,680 --> 00:28:29,540
going to be the AsyncTask framework so you
also as

591
00:28:29,540 --> 00:28:31,710
a side effect, get to learn a little bit

592
00:28:31,710 --> 00:28:34,340
more about how Async Task works under the
hood.

593
00:28:34,340 --> 00:28:37,920
Which implements this pattern in a very
cool and sophisticated way.

594
00:28:37,920 --> 00:28:39,240
It's not for the faint of heart.

595
00:28:39,240 --> 00:28:42,360
There's a lot of moving parts inside Async
Task, but I'll try

596
00:28:42,360 --> 00:28:45,040
to break it down for you so you can make
sense of it.

597
00:28:45,040 --> 00:28:46,590
Okay, so the first thing you do.

598
00:28:46,590 --> 00:28:49,560
If you want to implement this pattern you
got to figure out what your layers are.

599
00:28:49,560 --> 00:28:52,890
You've got to figure out what the, the
async layer is, you gotta figure out

600
00:28:52,890 --> 00:28:54,440
what the sync layer is, you have to

601
00:28:54,440 --> 00:28:57,120
figure how you're going to communicate
between them.

602
00:28:57,120 --> 00:29:01,090
So we're first going to start out by
looking at the, the async layer.

603
00:29:01,090 --> 00:29:02,460
So that's the part that's going to be the

604
00:29:02,460 --> 00:29:05,470
part where you're doing sort of short
duration things.

605
00:29:05,470 --> 00:29:10,190
In the context of our examples that would
be the stuff that gets called back by

606
00:29:10,190 --> 00:29:14,400
the Android activity framework when, or
the activity

607
00:29:14,400 --> 00:29:16,880
widget framework, when you click on a
button.

608
00:29:16,880 --> 00:29:19,850
So you get the, the view, the on-click
event

609
00:29:19,850 --> 00:29:23,090
called back that you designated in your
manifest file.

610
00:29:23,090 --> 00:29:28,330
And you get back the event that occurred,
and that's sort of the, the async part.

611
00:29:28,330 --> 00:29:30,870
And for our particular example here, we're
going to look at

612
00:29:30,870 --> 00:29:33,270
it as though someone were going to use the
async task framework.

613
00:29:33,270 --> 00:29:35,470
So what they would typically do is they
would bundle up

614
00:29:35,470 --> 00:29:38,470
whatever they got in, like a URL or
something like that.

615
00:29:38,470 --> 00:29:41,150
And then you'd go head and pass that in to

616
00:29:41,150 --> 00:29:46,240
the, the async task framework by calling
its execute method.

617
00:29:46,240 --> 00:29:48,396
And you all remember execute is this, this
template

618
00:29:48,396 --> 00:29:50,112
method that does a bunch of things for it.

619
00:29:50,112 --> 00:29:54,422
So if you take a look at execute, here is,
here is execute from the source code.

620
00:29:54,422 --> 00:29:56,576
we, we go and look on this in a more
detail in a second.

621
00:29:56,576 --> 00:29:59,087
But, basically what execute does, is it.

622
00:29:59,087 --> 00:30:03,104
Turns around and calls execute on
executor.

623
00:30:03,104 --> 00:30:05,850
And it passes in, something called the
DefaultExecutor.

624
00:30:05,850 --> 00:30:07,770
And we'll look at that in a second, too.

625
00:30:07,770 --> 00:30:12,070
By default, it does things in a sort of a
single threaded manner.

626
00:30:12,070 --> 00:30:16,690
But, it's easy very, very easy to do
multiple thread stuff.

627
00:30:16,690 --> 00:30:20,210
And then execute an executor does the
following.

628
00:30:20,210 --> 00:30:24,980
So, it turns around and it first does a
bunch of stuff and it goes onPreExecute.

629
00:30:24,980 --> 00:30:28,600
So keep in mind, we are in the user
interface thread of control at this point.

630
00:30:28,600 --> 00:30:34,320
We call, or it calls the, the execute,
executor method calls onPreExecute.

631
00:30:34,320 --> 00:30:37,420
So, that's where that pre-execute hook
gets called back.

632
00:30:37,420 --> 00:30:39,400
And then it takes the parameter that were
passed

633
00:30:39,400 --> 00:30:42,090
in here, which are whatever you called
execute with.

634
00:30:42,090 --> 00:30:47,930
And it sticks them into a data structure
and then it says exec,

635
00:30:47,930 --> 00:30:52,720
which is this executor, execute, and then
it passes in something called a future.

636
00:30:52,720 --> 00:30:55,260
And the futures going to be used, so that
the, the

637
00:30:55,260 --> 00:30:57,400
guy who ends up running this thing in the
background

638
00:30:57,400 --> 00:31:01,130
later can communicate back to the user
interface thread to

639
00:31:01,130 --> 00:31:04,770
do things like give progress updates and
other kinds of stuff.

640
00:31:04,770 --> 00:31:07,040
Okay, so that's, that's kind of the first
thing, and we'll

641
00:31:07,040 --> 00:31:08,390
take a look a the source code here in a
second.

642
00:31:09,690 --> 00:31:11,860
The next thing you want to be able to do
is you want to

643
00:31:11,860 --> 00:31:15,290
be able to figure out what stuff is
going to run for long time.

644
00:31:15,290 --> 00:31:17,340
So in the context of our particular
example,

645
00:31:17,340 --> 00:31:19,880
that's going to be the, the downloading of
the file.

646
00:31:19,880 --> 00:31:23,710
And the way that that happens of course in
the AsyncTask framework.

647
00:31:23,710 --> 00:31:25,280
If you poke around here for a while.

648
00:31:26,610 --> 00:31:31,150
When the constructor of AsyncTask is first
called

649
00:31:31,150 --> 00:31:35,360
it creates something that's called a
worker, an

650
00:31:35,360 --> 00:31:38,740
mWorker of type WorkerRunnable, and this
is basically

651
00:31:38,740 --> 00:31:41,520
a future, it's a, it's, it's a callable.

652
00:31:41,520 --> 00:31:43,000
It's a, it's a runable and a callable.

653
00:31:43,000 --> 00:31:45,110
Is it kind of combines a bunch of things
together.

654
00:31:45,110 --> 00:31:48,370
And its got this hook method on it called
call.

655
00:31:48,370 --> 00:31:51,785
And this method is going to be called,
when

656
00:31:51,785 --> 00:31:57,210
you're in the thread of control of the
background thread.

657
00:31:58,220 --> 00:31:59,330
And as you can see what it's going to do.

658
00:31:59,330 --> 00:32:02,190
This, this thing gets called in the
background thread.

659
00:32:02,190 --> 00:32:04,260
And it's going to go ahead and call

660
00:32:04,260 --> 00:32:07,640
doInBackground with the parameters that
you passed it.

661
00:32:07,640 --> 00:32:09,330
So that's going to go ahead and run in the
background.

662
00:32:09,330 --> 00:32:11,790
When that thing is done, it's going to
return the result.

663
00:32:11,790 --> 00:32:15,950
And that result's going to get posted back
to the user interface thread.

664
00:32:15,950 --> 00:32:18,090
And we're going to, we're going to look at
how all that stuff works in a second.

665
00:32:18,090 --> 00:32:18,660
It's really cool.

666
00:32:20,730 --> 00:32:21,420
Okay.

667
00:32:21,420 --> 00:32:23,900
And then the last thing we need, is we
need some

668
00:32:23,900 --> 00:32:27,020
way to be able to interact between the
Async part which

669
00:32:27,020 --> 00:32:29,190
is kind of that front end part that does
the execute and

670
00:32:29,190 --> 00:32:35,280
execute on executor part on behalf of the
UIThread activity logic.

671
00:32:35,280 --> 00:32:37,310
And then get the data over to the

672
00:32:37,310 --> 00:32:41,180
background thread and run it in the
doInBackground method.

673
00:32:41,180 --> 00:32:42,920
So, how are we going to do that?

674
00:32:42,920 --> 00:32:45,050
Well, the way we do that as indicated by
the

675
00:32:45,050 --> 00:32:49,380
pattern as, as foretold by the pattern
like a soothsayer.

676
00:32:49,380 --> 00:32:51,430
We're going to do that by having some kind
of BlockingQueue.

677
00:32:51,430 --> 00:32:53,960
And as you can see here, what do you know?

678
00:32:53,960 --> 00:32:55,430
It's called BlockingQueue.

679
00:32:55,430 --> 00:32:59,490
So, if you take a look inside of the
ThreadPoolExecutor, which we'll

680
00:32:59,490 --> 00:33:03,880
look at in a second, you'll see that the
ThreadPoolExecutor has a BlockingQueue.

681
00:33:03,880 --> 00:33:06,040
And as long as you give something here
that's

682
00:33:06,040 --> 00:33:09,980
a subclass of BlockingQueue, then it will
block properly.

683
00:33:09,980 --> 00:33:11,120
And the right things will happen.

684
00:33:11,120 --> 00:33:12,159
So, that's how we queue things up.

685
00:33:13,840 --> 00:33:14,500
Okay.

686
00:33:14,500 --> 00:33:20,627
So let's now go take a look and see how
all this stuff works.

687
00:33:20,627 --> 00:33:23,529
[BLANK_AUDIO]

688
00:33:23,529 --> 00:33:25,210
So here's the AsyncTask file.

689
00:33:25,210 --> 00:33:27,370
Lemme, lemme see if I can make it a little
bit

690
00:33:27,370 --> 00:33:31,718
smaller without completely, making it so
small you can't see it anymore.

691
00:33:31,718 --> 00:33:35,393
[NOISE].

692
00:33:35,393 --> 00:33:37,760
All right, hopefully you can sort of see
that.

693
00:33:37,760 --> 00:33:42,250
So one of the nice things about, about all
the Android code is it's all Javadoc.

694
00:33:42,250 --> 00:33:45,060
So, everything you see online is actually

695
00:33:45,060 --> 00:33:49,990
enclosed included in comments in the class
itself.

696
00:33:49,990 --> 00:33:52,180
So, we can kind of skip that to adhere at
all the things.

697
00:33:52,180 --> 00:33:54,875
So here you can see that we have
AsyncTask.

698
00:33:54,875 --> 00:33:58,150
AsyncTask is an abstract class which means
you are

699
00:33:58,150 --> 00:34:01,290
obligated to subclass it and fill in some
methods.

700
00:34:01,290 --> 00:34:05,490
The methods are obviously ones like
onPreExecute, onPostExecute, and so on.

701
00:34:06,570 --> 00:34:10,140
And then it has, it's generic class, so
you have to pass in some parameters.

702
00:34:10,140 --> 00:34:13,260
You have to pass in the parameters that
get passed to execute,

703
00:34:13,260 --> 00:34:17,120
which would be things like you know,
passing in a string or URL.

704
00:34:17,120 --> 00:34:19,910
The progress variable, which is used to
call back when

705
00:34:19,910 --> 00:34:24,180
you do the on, onProgressUpdate stuff or
the progress update method.

706
00:34:24,180 --> 00:34:28,320
And then the result, which is what gets
returned from doing back call.

707
00:34:28,320 --> 00:34:30,060
So, take a look here, you can see we've
got

708
00:34:30,060 --> 00:34:33,920
a couple of things that are used to have
default size.

709
00:34:33,920 --> 00:34:37,231
The, the thread pool, by default, the
thread pool will be 5.

710
00:34:37,231 --> 00:34:39,480
You'll have five things running in the
thread pool.

711
00:34:39,480 --> 00:34:41,270
The maximum size is going to be a 128.

712
00:34:41,270 --> 00:34:43,530
They just decided, no more threads than
that.

713
00:34:43,530 --> 00:34:44,716
It's probably not a bad idea.

714
00:34:44,716 --> 00:34:48,150
There's this thing called a ThreadFactory
which can be used to

715
00:34:48,150 --> 00:34:50,225
make threads and keep track of how many
threads we have.

716
00:34:50,225 --> 00:34:54,905
There's this thing that's called the, the
BlockingQueue, as you can see the

717
00:34:54,905 --> 00:34:57,530
BlockingQueue here is a
LinkedBlockingQueue, so its

718
00:34:57,530 --> 00:35:00,738
our queue made out of linked list.

719
00:35:00,738 --> 00:35:04,380
And I'm assuming that 10 here, probably
means the number of elements

720
00:35:04,380 --> 00:35:06,170
that can be in the queue before the queue
is considered full.

721
00:35:06,170 --> 00:35:09,360
We'll see how that figures in a, in a
little bit later,.

722
00:35:09,360 --> 00:35:10,410
Now here's something interesting.

723
00:35:10,410 --> 00:35:11,870
This is sort of the workhorse behind the

724
00:35:11,870 --> 00:35:15,230
scenes that's doing the heavy lifting for
AsyncTask.

725
00:35:15,230 --> 00:35:18,230
The workhorse for AsyncTask is some
kind of executor.

726
00:35:18,230 --> 00:35:21,210
And we'll say that there's, there's two of
them that are typically there.

727
00:35:21,210 --> 00:35:22,820
You are free to define your own executor.

728
00:35:22,820 --> 00:35:25,770
If you don't like the two that come out of
the box, you can make your own.

729
00:35:25,770 --> 00:35:29,811
But the two that come out of the box are
ThreadPoolExecutor and

730
00:35:29,811 --> 00:35:34,082
SerialExecutor, which are actually related
to each other in an interesting way.

731
00:35:34,082 --> 00:35:36,205
So ThreadPoolExecutor, when you call that
you give it

732
00:35:36,205 --> 00:35:39,120
the, the default number of threads, the
maximum number

733
00:35:39,120 --> 00:35:42,560
of threads you want, and some other things
like

734
00:35:42,560 --> 00:35:45,260
the, the worker queue, the blocking queue,
and so on.

735
00:35:45,260 --> 00:35:46,759
And that's going to create an object and
that's

736
00:35:46,759 --> 00:35:48,380
going to spawn a bunch of threads in the
background.

737
00:35:48,380 --> 00:35:50,239
And we'll see later how that, how that all
works.

738
00:35:51,680 --> 00:35:53,265
But then we are also going to make this
thing called a

739
00:35:53,265 --> 00:35:55,460
SerialExecutive, which is a new
SERIAL_EXECUTOR

740
00:35:55,460 --> 00:35:56,890
which we can see down here.

741
00:35:56,890 --> 00:35:59,760
There's, an InternalHandler that we use to
synchronize

742
00:35:59,760 --> 00:36:02,460
communication back to the main thread, the
UIThread.

743
00:36:02,460 --> 00:36:03,947
That, that, that's of course is done in

744
00:36:03,947 --> 00:36:05,820
the UIThread, so that it's owned by the
UIThread.

745
00:36:05,820 --> 00:36:09,029
We make the DefaultExecutor be the
SERIAL_EXECUTOR.

746
00:36:10,180 --> 00:36:11,820
And then here is the SerialExecutor.

747
00:36:11,820 --> 00:36:15,180
So, by default, an AsyncTask is a
SerialExecutor.

748
00:36:15,180 --> 00:36:18,060
And when its execute method gets called,
that

749
00:36:18,060 --> 00:36:21,990
turns around and calls this executive
method here.

750
00:36:21,990 --> 00:36:24,690
And it's going to end up passing in a
runnable.

751
00:36:24,690 --> 00:36:33,350
And you can see what we do here, is we go
ahead and we queue this runnable into

752
00:36:33,350 --> 00:36:39,550
the thing called task, we have a, a queue
of tasks which is a, a deck of runnables.

753
00:36:39,550 --> 00:36:41,825
And we stick this thing in here.

754
00:36:41,825 --> 00:36:47,460
And, we put a runnable in this queue, and
then if there's nothing that's

755
00:36:47,460 --> 00:36:48,850
currently active, which there won't be
when

756
00:36:48,850 --> 00:36:51,832
we're first setting here, we call
scheduleNext.

757
00:36:51,832 --> 00:36:54,180
And scheduleNext goes ahead and takes this
thing off

758
00:36:54,180 --> 00:36:58,450
the queue, and then it executes it in the
THREAD_POOL_EXECUTOR.

759
00:36:58,450 --> 00:37:02,960
But it's only letting one thing at a time,
be executed in the THREAD_POOL_EXECUTOR.

760
00:37:02,960 --> 00:37:08,136
And when that guy is done, then, you know,
what will happen is, when the

761
00:37:08,136 --> 00:37:13,120
run method is finished this guy will come
back and then schedule the next thing.

762
00:37:13,120 --> 00:37:16,110
So we're basically building a linked list
of requests

763
00:37:16,110 --> 00:37:18,050
and then they're being executed one at a
time.

764
00:37:18,050 --> 00:37:19,980
So they're actually not running in
parallel.

765
00:37:19,980 --> 00:37:21,340
Just one of them is running at a time.

766
00:37:21,340 --> 00:37:23,882
That's what the SerialExecutor does.

767
00:37:23,882 --> 00:37:25,290
The THREAD_POOL_EXECUTOR when you do it
with

768
00:37:25,290 --> 00:37:27,210
the multi-threaded version is even more,
more cool.

769
00:37:27,210 --> 00:37:28,079
We'll see that in a second.

770
00:37:29,230 --> 00:37:29,500
All right.

771
00:37:29,500 --> 00:37:30,960
So lets take a look at a few more things.

772
00:37:30,960 --> 00:37:34,920
You can see you can set the executor to
something besides the, the default.

773
00:37:36,080 --> 00:37:37,130
Here's the constructor.

774
00:37:37,130 --> 00:37:39,700
When you, when you make an AsyncTask, when

775
00:37:39,700 --> 00:37:43,390
you say, you know, AsyncTask A equal new
AsyncTask.

776
00:37:43,390 --> 00:37:44,650
Here's what happens.

777
00:37:44,650 --> 00:37:47,960
It goes ahead and it creates this thing
called a WorkerRunable.

778
00:37:47,960 --> 00:37:49,600
Which is going to end up being stuck.

779
00:37:49,600 --> 00:37:53,970
As we'll see in a second onto a queue that
gets passed to

780
00:37:53,970 --> 00:37:58,490
a thread in the thread pool that the
executor's running in a background thread.

781
00:37:58,490 --> 00:38:02,300
And, when it's called back, what this guy
does is it goes ahead

782
00:38:02,300 --> 00:38:08,229
and runs the doInBackground method of this
task in the other thread of control.

783
00:38:10,170 --> 00:38:11,595
And then we go ahead make this thing
called a

784
00:38:11,595 --> 00:38:17,430
FutureTask, and you can see the FutureTask
actually holds the worker.

785
00:38:17,430 --> 00:38:20,550
So the worker is the guy who's going to do
the work in the other thread.

786
00:38:20,550 --> 00:38:25,020
The FutureTask then gets created, and this
FutureTask when this guy

787
00:38:25,020 --> 00:38:28,550
is done, what he's going to do, is he's
going to end up getting

788
00:38:28,550 --> 00:38:33,490
the result and posting the result back to
the main thread of

789
00:38:33,490 --> 00:38:39,280
control, so that the onPostExecute method
gets called in the right context.

790
00:38:40,430 --> 00:38:42,010
So keep in mind what these things are
what's

791
00:38:42,010 --> 00:38:44,090
confusing about this if you're not really
a Java expert

792
00:38:44,090 --> 00:38:48,070
is for making objects that have methods
that don't get

793
00:38:48,070 --> 00:38:51,490
run until they get called back at the
right time.

794
00:38:51,490 --> 00:38:53,290
So, this guy over here for example, his
call

795
00:38:53,290 --> 00:38:55,420
method's going to be called back in the
background thread.

796
00:38:55,420 --> 00:38:58,200
And when this done method gets called back
he's also going to

797
00:38:58,200 --> 00:39:01,410
get call the background thread and he's
going to post the result.

798
00:39:01,410 --> 00:39:03,390
So it ends up going back where it needs to
go.

799
00:39:05,500 --> 00:39:06,150
Okay.

800
00:39:06,150 --> 00:39:07,840
So there's a bunch of other little helper
methods.

801
00:39:07,840 --> 00:39:08,770
Here's an interesting one.

802
00:39:10,160 --> 00:39:13,296
This is an idiom you see a lot in Android,
by the way.

803
00:39:13,296 --> 00:39:15,840
So a postResult let's see where this gets
called.

804
00:39:15,840 --> 00:39:17,055
So take a look at postResult.

805
00:39:17,055 --> 00:39:19,327
[NOISE].

806
00:39:19,327 --> 00:39:21,490
So here's an example postResult.

807
00:39:21,490 --> 00:39:27,160
When we ran the background, when we ran
doInBackground in the background thread.

808
00:39:27,160 --> 00:39:29,460
When we were finished running in the
background thread it returned

809
00:39:29,460 --> 00:39:32,300
a result, which was the, like the bit map
or whatever.

810
00:39:32,300 --> 00:39:35,240
And it's going to post that result.

811
00:39:35,240 --> 00:39:40,270
So we go here, postResult takes the result
and it goes ahead and then it says.

812
00:39:40,270 --> 00:39:43,930
Hey, handler, that's owned by the main
thread of control, by the UIThread.

813
00:39:43,930 --> 00:39:46,410
It says, make me a message please.

814
00:39:46,410 --> 00:39:48,900
And it's going to be the
MESSAGE_POST_RESULT message.

815
00:39:48,900 --> 00:39:51,310
And I want you to associate with this the

816
00:39:51,310 --> 00:39:53,830
result that we just computed in the
background thread.

817
00:39:53,830 --> 00:39:56,890
And then it's going to go ahead and it's
going to take that message, remember this

818
00:39:56,890 --> 00:40:01,370
message comes out of the handler for the
main thread of control, the UIThread.

819
00:40:01,370 --> 00:40:05,130
And then it's going to say message, send
yourself to this target.

820
00:40:05,130 --> 00:40:07,690
So what it'll do is under the hood it'll
take the result that

821
00:40:07,690 --> 00:40:11,120
was just computed, running in the
background, and it will stick it on

822
00:40:11,120 --> 00:40:16,380
the message queue for the UIThread, and
the UIThread will then come along

823
00:40:16,380 --> 00:40:20,800
and read that thing out of there and then
crack this request open.

824
00:40:20,800 --> 00:40:22,470
And then do a callback which will then go

825
00:40:22,470 --> 00:40:24,640
ahead and then display it in the right
place.

826
00:40:25,730 --> 00:40:28,990
So if you take a look down here, here's
doInBackground you can

827
00:40:28,990 --> 00:40:34,620
see that that's a, doInBackground is an
abstract method which means you have

828
00:40:34,620 --> 00:40:39,129
to subclass it onPreExecute and
onPostExecute

829
00:40:39,129 --> 00:40:40,660
are just virtual methods that are

830
00:40:40,660 --> 00:40:43,130
not abstract so they, you can ignore them
and they will still work.

831
00:40:44,306 --> 00:40:47,510
Here's onProgressUpdate, here's
onCancelled and so on and so forth.

832
00:40:48,850 --> 00:40:49,400
Let's see.

833
00:40:49,400 --> 00:40:52,370
Trying to think if there's anything else
interesting.

834
00:40:52,370 --> 00:40:54,430
I should show you here.

835
00:40:55,870 --> 00:40:59,425
Here's the execute method, we saw that
actually says execute on executive.

836
00:41:00,950 --> 00:41:04,960
Here's execute on executor this guy goes
ahead and

837
00:41:04,960 --> 00:41:07,920
does the onPreExecute, because it's in the
main thread control.

838
00:41:07,920 --> 00:41:10,620
And then it goes ahead and executes the

839
00:41:10,620 --> 00:41:13,320
future, and it passes it to the
background.

840
00:41:13,320 --> 00:41:17,370
We'll look at that in a second and see how
all that works.

841
00:41:17,370 --> 00:41:18,220
Lets see.

842
00:41:18,220 --> 00:41:18,780
Oh, here you go.

843
00:41:18,780 --> 00:41:20,330
PublishedProgress.

844
00:41:20,330 --> 00:41:22,927
when you call publishProgress that's,
that's how

845
00:41:22,927 --> 00:41:25,004
you, you publish data from the background

846
00:41:25,004 --> 00:41:28,880
thread to show up if I had called to
onProgressUpdate in the foreground thread.

847
00:41:28,880 --> 00:41:33,403
You can see what it does, is it goes ahead
and it gets a message from the handler

848
00:41:33,403 --> 00:41:36,885
that's running, owned by the main threader
control, and

849
00:41:36,885 --> 00:41:41,440
it says I'm going to pass the
MESSAGE_POST_PROGRESS message, please.

850
00:41:41,440 --> 00:41:44,150
And then you can see it just goes ahead
and sends that to target.

851
00:41:44,150 --> 00:41:45,620
So, it sends it right over there.

852
00:41:45,620 --> 00:41:48,450
Notice it doesn't even cache the message
anywhere, it just chains it together.

853
00:41:48,450 --> 00:41:52,710
It says sHandler, a ping message, send to
target.

854
00:41:52,710 --> 00:41:55,010
It's almost like a list, it's kind of
chaining all the stuff together.

855
00:41:56,312 --> 00:42:00,070
Here's the, the finish method, you can see
what finish does.

856
00:42:00,070 --> 00:42:03,770
When finish is called it takes the result
and it calls onPostExecute.

857
00:42:03,770 --> 00:42:05,850
So that's obviously how we're going to get
the result that

858
00:42:05,850 --> 00:42:08,098
was computed in the background to run in
the UIThread.

859
00:42:08,098 --> 00:42:12,140
Here's the InternalHandler, this is the
guy

860
00:42:12,140 --> 00:42:13,980
that actually does the stuff in the
background.

861
00:42:13,980 --> 00:42:16,750
And you could see that he defines a class,
and this is

862
00:42:16,750 --> 00:42:21,850
another common thing that I, a lot of
people didn't properly handle the

863
00:42:22,890 --> 00:42:26,370
memory leak issues, where you have to make
sure you have specific classes

864
00:42:26,370 --> 00:42:29,748
not anonymous classes to deal with memory
issues that, that's a common problem.

865
00:42:29,748 --> 00:42:31,680
Read that link that I sent in your,

866
00:42:31,680 --> 00:42:34,540
in my chemistry solution for more
information like that.

867
00:42:34,540 --> 00:42:37,290
So, whatever anybody sends these messages
from

868
00:42:37,290 --> 00:42:39,080
the background thread to post the
progress, to

869
00:42:39,080 --> 00:42:41,290
post the result that's the ends up coming

870
00:42:41,290 --> 00:42:44,180
through here in the main thread of
control.

871
00:42:44,180 --> 00:42:47,847
And what it does if it's is the
MESSAGE_POST_RESULT

872
00:42:47,847 --> 00:42:50,430
it says go ahead and finish with the
result data.

873
00:42:50,430 --> 00:42:56,000
If it's MESSAGE_POST_PROGRESS it says call
the onPostUpdate where the result data.

874
00:42:57,240 --> 00:42:58,580
So those, those things are how we get

875
00:42:58,580 --> 00:43:00,540
data from the background thread to the
foreground

876
00:43:00,540 --> 00:43:03,600
thread to be called back appropriately on
the

877
00:43:03,600 --> 00:43:07,935
appropriate hook method that, that's done
on the AsyncTask.

878
00:43:09,520 --> 00:43:13,750
And then this WorkableRunnable class is a
callable that adds a bit of data.

879
00:43:15,580 --> 00:43:19,060
Okay, so that's, that's kind of how
asynctask works.

880
00:43:19,060 --> 00:43:21,122
Now the other thing I want to show you
here

881
00:43:21,122 --> 00:43:25,500
real quick, is it's also quite
interesting, is the ThreadPoolExecutor.

882
00:43:25,500 --> 00:43:27,266
And this is the guy that does all the
work.

883
00:43:27,266 --> 00:43:30,280
So the AsyncTask is really just there, in
order to

884
00:43:30,280 --> 00:43:34,380
be able to fill the framework obligations
of getting, doing

885
00:43:34,380 --> 00:43:38,939
background work, running, running in one
thread, and on pre,

886
00:43:38,939 --> 00:43:42,120
onPreExecute, onPostExecute,
onProgressUpdate; getting those

887
00:43:42,120 --> 00:43:42,930
running in the other thread.

888
00:43:42,930 --> 00:43:46,760
And then being able to pass futures and
work worker

889
00:43:46,760 --> 00:43:50,380
objects back and forth between the threads
using the message mechanisms.

890
00:43:50,380 --> 00:43:52,210
And a half sync, async pattern.

891
00:43:52,210 --> 00:43:53,740
So that's what that things doing.

892
00:43:53,740 --> 00:43:55,370
The guy that actually does the heavy
lifting to

893
00:43:55,370 --> 00:43:59,210
run the stuff in the background is the
ThreadPoolExecutor.

894
00:43:59,210 --> 00:44:00,700
And if you read this thing you'll realize

895
00:44:00,700 --> 00:44:03,610
that they really thought this through very
very thoroughly.

896
00:44:03,610 --> 00:44:07,320
My friend in colleague for gosh, almost 30
years, Doug Lee.

897
00:44:08,390 --> 00:44:12,970
great, fantastic computer programmer,
researcher, academic.

898
00:44:12,970 --> 00:44:17,290
He's the author of this stuff and it's
very, very sophisticated.

899
00:44:17,290 --> 00:44:20,320
Basically, it's got a lots and lots of
different tweaks little,

900
00:44:20,320 --> 00:44:23,890
little knobs you can turn to do all kinds
of different things.

901
00:44:23,890 --> 00:44:24,430
Theres, he's the author.

902
00:44:25,600 --> 00:44:28,068
And so you can, you can either have a

903
00:44:28,068 --> 00:44:32,200
fixed number of threads or a fixed number
of messages.

904
00:44:32,200 --> 00:44:33,615
Or unbounded number [LAUGH], an unbounded
number

905
00:44:33,615 --> 00:44:35,000
of threads, an unbounded number of
messages.

906
00:44:35,000 --> 00:44:37,970
You can, you can play with all these
different parameters, there's

907
00:44:37,970 --> 00:44:41,210
a couple of different options they give
you, to start with.

908
00:44:41,210 --> 00:44:44,870
A lot of this stuff is, is just low level
things.

909
00:44:44,870 --> 00:44:47,930
Here's the blocking queue we were talking
about before, that's the thing that

910
00:44:47,930 --> 00:44:51,140
does the synchronization, not unlike the

911
00:44:51,140 --> 00:44:53,270
active object pattern that we talked
about.

912
00:44:53,270 --> 00:44:55,529
We have some locks in here.

913
00:44:55,529 --> 00:44:58,749
We have a hash set of worker threads in a
pool, so

914
00:44:58,749 --> 00:45:02,425
we can look them up by their, their ID to
find them quickly.

915
00:45:02,425 --> 00:45:04,857
What I really want to show you here was
the main

916
00:45:04,857 --> 00:45:07,760
method, which is the guy that, that does
the work.

917
00:45:07,760 --> 00:45:11,748
[BLANK_AUDIO]

918
00:45:11,748 --> 00:45:12,174
There we go.

919
00:45:12,174 --> 00:45:14,010
So here's, here's execute.

920
00:45:14,010 --> 00:45:17,010
You call execute, you give it something
that's ultimately a runnable.

921
00:45:17,010 --> 00:45:20,060
[COUGH] And, what this thing comes in and
it says.

922
00:45:20,060 --> 00:45:23,730
It says, is the number of threads in our
pool, that's, that are

923
00:45:23,730 --> 00:45:28,830
currently running, is that less than the,
the size we are allowed to have?

924
00:45:28,830 --> 00:45:30,910
And if the answer is yes, it will try to
add a

925
00:45:30,910 --> 00:45:35,060
new worker thread and then give the work
to that worker thread.

926
00:45:35,060 --> 00:45:36,870
So that's one way it does stuff.

927
00:45:36,870 --> 00:45:40,840
If there's already enough threads that are
running, it then says.

928
00:45:40,840 --> 00:45:46,330
Can I go ahead and add this particular
command into the queue of commands?

929
00:45:46,330 --> 00:45:46,830
Yes or no?

930
00:45:47,868 --> 00:45:51,010
And if the answer is yes, then we are
fine.

931
00:45:51,010 --> 00:45:53,250
If the answer is no because the queue is
full,

932
00:45:53,250 --> 00:45:55,360
then in that particular case we may reject
the thing.

933
00:45:56,380 --> 00:45:57,860
And then it tries to do some other stuff.

934
00:45:57,860 --> 00:45:59,890
If you do the documentation you'll see how
the different.

935
00:45:59,890 --> 00:46:02,780
Logic it tries to do to figure out what,
what's going to work.

936
00:46:02,780 --> 00:46:04,420
For our particular case here we have, you
know,

937
00:46:04,420 --> 00:46:07,000
five threads and I think ten items in the
queue.

938
00:46:07,000 --> 00:46:10,920
And so as long as we don't exceed those
limits it's going to pre spawn

939
00:46:10,920 --> 00:46:15,690
those five threads and as work comes in
it'll stick it onto the queue by offer.

940
00:46:15,690 --> 00:46:19,300
And then if we take a look up here there's
a.

941
00:46:19,300 --> 00:46:21,950
I think it's called take, yeah so.

942
00:46:21,950 --> 00:46:26,410
There's a method called get task, and get
task is going to be called by

943
00:46:26,410 --> 00:46:29,240
the background thread in order to get the
next chunk of work to do.

944
00:46:29,240 --> 00:46:33,740
And it does a whole bunch of different
stuff to check it's state and context.

945
00:46:33,740 --> 00:46:37,140
And then finally, it goes ahead and it
tries to get.

946
00:46:37,140 --> 00:46:40,090
The next item out of the queue, using
timeouts or not.

947
00:46:40,090 --> 00:46:43,440
Unless it's got that thing, it's got the
runnable that it wants to execute.

948
00:46:43,440 --> 00:46:47,660
So if you take a look at the task, so you
can see the run worker thread.

949
00:46:47,660 --> 00:46:51,320
Run worker thread is the actual method
that gets run in a thread and it

950
00:46:51,320 --> 00:46:56,240
blocks waiting for there to be work to do,
it gets the next task to run.

951
00:46:56,240 --> 00:46:58,570
It calls them the four execute hooks.

952
00:46:58,570 --> 00:47:01,350
And then it goes ahead and says task run.

953
00:47:01,350 --> 00:47:05,230
And in our particular case, when you call
task run,

954
00:47:05,230 --> 00:47:10,290
that ends up calling the call method on
this callable thing.

955
00:47:11,320 --> 00:47:15,280
And as you can see here, when the worker
thread running in

956
00:47:15,280 --> 00:47:20,470
the pool by the thread pool executor runs,
it's going to go ahead and.

957
00:47:20,470 --> 00:47:22,780
Call rar, which is going to call call, and

958
00:47:22,780 --> 00:47:26,104
call is going to be, related, to this
callback.

959
00:47:26,104 --> 00:47:29,870
And that's going to end up calling do in
background from

960
00:47:29,870 --> 00:47:32,630
a thread in the thread pool to do it's
work.

961
00:47:32,630 --> 00:47:36,470
And when it's done its going to post it's
result back to the main thread.

962
00:47:36,470 --> 00:47:40,040
So, [COUGH] it's almost like watching a
game of pong or a game of tennis.

963
00:47:40,040 --> 00:47:43,580
Things are going back and forth, and back
and forth through these cues.

964
00:47:43,580 --> 00:47:46,810
But the key point is under the hood, it's
all working as a result of the half-async

965
00:47:46,810 --> 00:47:49,590
of the async pattern, where the main
thread is

966
00:47:49,590 --> 00:47:53,190
sending data to the worker threads through
a queue.

967
00:47:53,190 --> 00:47:54,920
The worker threads are pulling data stuff
out of

968
00:47:54,920 --> 00:47:58,070
the queue, doing the callbacks that do
during background.

969
00:47:58,070 --> 00:48:02,830
And when they are done, then their
invoking methods that return the results

970
00:48:02,830 --> 00:48:05,669
back to the queue that's owned by the main
thread of the control.

971
00:48:06,770 --> 00:48:08,870
And so that's basically how things are
interacting.

972
00:48:11,018 --> 00:48:15,130
All right, so that doesn't obviously cover
every last

973
00:48:15,130 --> 00:48:17,660
thing there is to know about Async task
and

974
00:48:17,660 --> 00:48:19,990
thread pool executor but it at least gives
you

975
00:48:19,990 --> 00:48:21,870
a feeling for how it works under the hood.

976
00:48:23,550 --> 00:48:28,180
So if we were to implement this in the
context of our example, we would have a.

977
00:48:28,180 --> 00:48:33,256
A class might download async task, how
like you guys load, we extend async task,

978
00:48:33,256 --> 00:48:39,020
we fill on string, integer and bitmap, and
then we define a do in background method.

979
00:48:39,020 --> 00:48:41,000
And that's the guy who's going to download
the

980
00:48:41,000 --> 00:48:43,110
thing in the background thread, so he can
block.

981
00:48:44,130 --> 00:48:49,070
We're going to implement the async side of
things so of course.

982
00:48:49,070 --> 00:48:51,530
Those are going to be the call backs that
we do to invoke things

983
00:48:51,530 --> 00:48:56,290
in the first place like execute, as well
as stuff like on, pre-execute.

984
00:48:56,290 --> 00:48:59,820
Which is going to go ahead and display our
dialog and on post-execute,

985
00:48:59,820 --> 00:49:04,240
which is going to go ahead and do the
operation and dismiss the dialog.

986
00:49:04,240 --> 00:49:05,940
So those are examples of the asynch parts.

987
00:49:05,940 --> 00:49:07,890
They, they run very quickly, they don't
block.

988
00:49:07,890 --> 00:49:09,340
So we want those running in the main
thread.

989
00:49:09,340 --> 00:49:11,120
We want the other stuff running in the
other thread.

990
00:49:11,120 --> 00:49:14,280
And the Async task framework make sure
that all things happen in the right place.

991
00:49:17,070 --> 00:49:18,600
And then we have the queueing layer which
is

992
00:49:18,600 --> 00:49:20,810
what we just looked at a minute ago where.

993
00:49:20,810 --> 00:49:23,300
You're going to have this work queue and
the work

994
00:49:23,300 --> 00:49:25,980
queue is going to be used to offer and
take the message,

995
00:49:25,980 --> 00:49:30,300
the messages which are actually runnables,
which are actually futures

996
00:49:30,300 --> 00:49:33,390
which can get called back to do various
things as callbacks.

997
00:49:33,390 --> 00:49:35,840
So it's, it's lots of patterns all glommed
together.

998
00:49:35,840 --> 00:49:39,860
This particular set of code has very high
pattern density, so

999
00:49:39,860 --> 00:49:42,020
in addition to the half sync, half async
pattern which is

1000
00:49:42,020 --> 00:49:45,100
kind of structuring the overall
interactions, we've also got, you know,

1001
00:49:45,100 --> 00:49:49,700
futures running around here a, you know,
other things that you've seen.

1002
00:49:49,700 --> 00:49:52,350
Factories and so on, and that should be no
surprise.

1003
00:49:52,350 --> 00:49:55,070
Doug Lee has been doing patterns for
decades.

1004
00:49:55,070 --> 00:49:58,670
And actually wrote the Forward to our
POSA2 book.

1005
00:49:58,670 --> 00:50:00,220
So he's very familiar with these patterns.

1006
00:50:02,050 --> 00:50:04,860
All right, next thing I'm going to is just
give you another view of all this stuff.

1007
00:50:04,860 --> 00:50:08,150
So I jus, I showed you how to implement
things.

1008
00:50:08,150 --> 00:50:12,420
But as you undoubtedly discover just
looking at source code is

1009
00:50:12,420 --> 00:50:17,180
often not sufficient to make sense out of
what the software does.

1010
00:50:17,180 --> 00:50:19,960
And that's because when you look at source
code.

1011
00:50:19,960 --> 00:50:24,220
You've got to build a mental model in your
head of who's calling what and when.

1012
00:50:24,220 --> 00:50:28,480
And unless you're extremely fluent with
these patterns, it's

1013
00:50:28,480 --> 00:50:31,730
easy to start losing track of what's going
on.

1014
00:50:31,730 --> 00:50:32,830
So how do we deal with this?

1015
00:50:32,830 --> 00:50:34,240
Well there's a variety of different means.

1016
00:50:34,240 --> 00:50:38,780
What I'm going to show you here, is a way
of using UML notation.

1017
00:50:38,780 --> 00:50:43,221
In particular, some concurrency notation
and some notation relating to interaction

1018
00:50:43,221 --> 00:50:47,890
diagrams to illustrate, illustrate the
sequence of flow of control here.

1019
00:50:47,890 --> 00:50:50,830
[COUGH] And, probably for the actual mook
I will animate all this stuff.

1020
00:50:50,830 --> 00:50:53,998
I didn't have a chance to do that yet but,
here's here's basically what happens.

1021
00:50:53,998 --> 00:50:59,830
So [COUGH] the, The UI thread gets a user
request, right?

1022
00:50:59,830 --> 00:51:00,440
How does that happen?

1023
00:51:00,440 --> 00:51:03,580
Somebody clicks a button, and you fill in
a text view.

1024
00:51:03,580 --> 00:51:06,200
And you, or, and edit text.

1025
00:51:06,200 --> 00:51:07,530
You, you click a button.

1026
00:51:07,530 --> 00:51:10,280
That shows up by some kind of click
handler, right?

1027
00:51:10,280 --> 00:51:11,560
That you wrote.

1028
00:51:11,560 --> 00:51:13,810
And you get that, you validate it, and
then you call execute.

1029
00:51:13,810 --> 00:51:17,200
And you give the URL that was part of the,
the data that was entered by the user.

1030
00:51:17,200 --> 00:51:19,697
So, [COUGH] let's say but for sake of
argument, we

1031
00:51:19,697 --> 00:51:22,440
set the ex, executor to be the thread pull
executor.

1032
00:51:22,440 --> 00:51:29,400
So, execute is called, execute as we just
saw turns around and calls on pre-execute.

1033
00:51:29,400 --> 00:51:30,370
That's the first thing it does.

1034
00:51:30,370 --> 00:51:33,120
So there's a hook method that gets called
back to your code

1035
00:51:33,120 --> 00:51:35,900
to do anything that's needed to run in the
main sort of control.

1036
00:51:35,900 --> 00:51:39,220
It then turns around and now keep in mind
this is all in the

1037
00:51:39,220 --> 00:51:43,640
UI thread like here, all the stuff inside
this dashed line is UI thread.

1038
00:51:43,640 --> 00:51:48,280
It then calls the execute method on the
executor and what

1039
00:51:48,280 --> 00:51:51,590
that guy does is he sticks this thing into
the blocking queue.

1040
00:51:51,590 --> 00:51:54,540
And I guess really strictly speaking I

1041
00:51:54,540 --> 00:51:56,580
should fix this because it's a little
confusing.

1042
00:51:57,690 --> 00:52:00,670
Somewhat strictly speaking, you know, the
worker threads are really

1043
00:52:00,670 --> 00:52:03,550
the guys who are running the separate
thread of control.

1044
00:52:03,550 --> 00:52:05,150
I will probably put this in a various
places.

1045
00:52:06,250 --> 00:52:09,210
[COUGH] Some sense it probably looks more
like that the boundary.

1046
00:52:09,210 --> 00:52:10,810
So when you call and execute, you call and

1047
00:52:10,810 --> 00:52:13,810
execute that's an object sort of half in,
half out,.

1048
00:52:13,810 --> 00:52:14,480
It's.

1049
00:52:14,480 --> 00:52:18,950
It's got a public facade for interacting
with it, that's called by a thread.

1050
00:52:18,950 --> 00:52:23,750
And that thing turns around, and sticks
the request into the blocking queue.

1051
00:52:23,750 --> 00:52:27,760
And then, one of the threads in the
background is going to

1052
00:52:27,760 --> 00:52:31,490
end up calling take, to take it out of the
queue.

1053
00:52:31,490 --> 00:52:34,550
And once it takes it out of the queue, it
then does this call.

1054
00:52:34,550 --> 00:52:37,620
Callback method in the background thread.

1055
00:52:37,620 --> 00:52:42,160
That will then call doInBackground, that
goes and runs over here, and, I'm sorry,

1056
00:52:42,160 --> 00:52:47,970
runs, and when it's when it's all done, it
will

1057
00:52:47,970 --> 00:52:50,860
go ahead and post the result, that ends up
coming back over

1058
00:52:50,860 --> 00:52:53,269
here, and this guy gets to run in the
other thread of control.

1059
00:52:55,700 --> 00:52:57,830
So the executor threads in the, in the

1060
00:52:57,830 --> 00:52:59,520
thread pool do all that work in the
background.

1061
00:53:01,090 --> 00:53:06,613
And under the hood the blocking queue is
what's really doing the, the

1062
00:53:06,613 --> 00:53:14,310
synchronization of interactions between
the half-sync and the half-async layer.

1063
00:53:14,310 --> 00:53:16,820
If there's flow control that occurs at all
here.

1064
00:53:16,820 --> 00:53:18,950
If, if you would happen to block in the
one sort of

1065
00:53:18,950 --> 00:53:22,580
control in, in a background thread that,
that's doing a download.

1066
00:53:22,580 --> 00:53:23,760
Not a problem.

1067
00:53:23,760 --> 00:53:25,200
Nobody else is affected.

1068
00:53:25,200 --> 00:53:26,070
Everything works just fine.

1069
00:53:27,500 --> 00:53:27,898
Okay.

1070
00:53:27,898 --> 00:53:31,550
So to kind of wrap things up, from

1071
00:53:31,550 --> 00:53:34,820
an android centric perspective, of this
pattern.

1072
00:53:34,820 --> 00:53:37,330
You kind of see here, this is, this is the
pattern, but now

1073
00:53:37,330 --> 00:53:41,620
we've replaced the generic parts with
specific things from the android toolkit.

1074
00:53:41,620 --> 00:53:43,840
So, we've got our external event source,
is

1075
00:53:43,840 --> 00:53:46,270
really coming at us, from the UI thread
looper.

1076
00:53:46,270 --> 00:53:47,720
That we looked at before.

1077
00:53:47,720 --> 00:53:51,065
Our activity is kind of the part that's
the Async part

1078
00:53:51,065 --> 00:53:52,880
is not blocking in there for any length of
time.

1079
00:53:52,880 --> 00:53:56,070
This will get the A and R exception.

1080
00:53:56,070 --> 00:53:58,950
And then we're offering stuff into the
blocking

1081
00:53:58,950 --> 00:54:00,800
queue which is part of the Async task
framework.

1082
00:54:00,800 --> 00:54:04,480
And then these background threads, they
are pulling stuff of the queue.

1083
00:54:04,480 --> 00:54:06,100
Processing it and then they're.

1084
00:54:06,100 --> 00:54:08,560
Eventually passing data back to the UI

1085
00:54:08,560 --> 00:54:12,130
thread through the, through the internal
handler

1086
00:54:12,130 --> 00:54:15,300
mechanism that's used to synchronize
messages between

1087
00:54:15,300 --> 00:54:17,320
the background threads and the foreground
threads.

1088
00:54:17,320 --> 00:54:20,000
So, this is actually, as, as I said, well
I'll get to that in a second.

1089
00:54:20,000 --> 00:54:20,560
So.

1090
00:54:20,560 --> 00:54:23,270
This encapsulates background thread
processing, it

1091
00:54:23,270 --> 00:54:24,640
decouples it from the UI thread.

1092
00:54:24,640 --> 00:54:27,850
You can also report progress.

1093
00:54:27,850 --> 00:54:30,430
The half-sync, the async task framework is

1094
00:54:30,430 --> 00:54:34,230
a very sophisticated implementation of
half-sync, half-async pattern.

1095
00:54:34,230 --> 00:54:37,900
And it's sophisticated because unlike many
instances of this pattern,

1096
00:54:37,900 --> 00:54:41,040
where data just flows from the bottom to
the top.

1097
00:54:41,040 --> 00:54:44,090
We have data flowing from the bottom to
the top, or from one side to the other.

1098
00:54:44,090 --> 00:54:44,810
It that's how you look at it.

1099
00:54:44,810 --> 00:54:47,440
And then there's also stuff that's coming
back the other way.

1100
00:54:47,440 --> 00:54:49,770
So we're not just having one-way
communication.

1101
00:54:49,770 --> 00:54:52,830
We, we're talking from the activity, to
the background thread.

1102
00:54:52,830 --> 00:54:55,510
And then from the background thread to the
foreground thread.

1103
00:54:55,510 --> 00:55:01,330
And, and sometimes, as is the case with
the post-progress stuff.

1104
00:55:01,330 --> 00:55:02,590
That happens multiple times.

1105
00:55:02,590 --> 00:55:06,710
You, you keep calling back and forth, back
and forth for the duration of the call.

1106
00:55:06,710 --> 00:55:08,260
So there's, there's multiple points of

1107
00:55:08,260 --> 00:55:11,950
interaction be, between background and
foreground threads.

1108
00:55:11,950 --> 00:55:12,570
Or UI threads.

1109
00:55:14,140 --> 00:55:18,160
Okay, [COUGH] any, any questions about
that particular.

1110
00:55:18,160 --> 00:55:20,150
Pattern or that framework.

1111
00:55:20,150 --> 00:55:23,140
So now hopefully you have a much better
understanding of a couple things.

1112
00:55:23,140 --> 00:55:25,930
You hopefully know a bit more about basic

1113
00:55:25,930 --> 00:55:28,400
task framework and how it works under the
hood,

1114
00:55:28,400 --> 00:55:29,930
you might see how it's implemented as a

1115
00:55:29,930 --> 00:55:32,100
pattern, which helps it easier to
understand the implementation.

1116
00:55:32,100 --> 00:55:35,530
And probably the most important thing you
learn is nobody

1117
00:55:35,530 --> 00:55:39,390
in their right mind would want to
implement Async task.

1118
00:55:39,390 --> 00:55:42,150
If they could use it from what's already
in Android.

1119
00:55:42,150 --> 00:55:46,370
So it's a great story about how patterns
and frameworks collaborate

1120
00:55:46,370 --> 00:55:50,090
to make your life easier if you're needs
match what it does.

1121
00:55:50,090 --> 00:55:56,142
[MUSIC].

