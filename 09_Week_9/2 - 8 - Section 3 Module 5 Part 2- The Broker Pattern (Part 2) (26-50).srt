1
00:00:00,000 --> 00:00:08,463
[MUSIC]

2
00:00:08,463 --> 00:00:11,555
Okay, so today we're going to continue
talking about

3
00:00:11,555 --> 00:00:15,120
the Broker pattern, focusing on the
implementation of Broker

4
00:00:15,120 --> 00:00:17,674
in the context of Android, as well as
talking

5
00:00:17,674 --> 00:00:21,490
more generally about what it means to
implement Broker.

6
00:00:21,490 --> 00:00:22,580
And we're also going to talk

7
00:00:22,580 --> 00:00:26,550
about another pattern called the
Publisher-Subscriber pattern.

8
00:00:26,550 --> 00:00:29,710
And we'll talk about how those things are
realized in Android as well.

9
00:00:29,710 --> 00:00:30,970
So first let's talk about the Broker.

10
00:00:30,970 --> 00:00:33,190
If you recall, last class, at the end of

11
00:00:33,190 --> 00:00:35,580
last class, we talked about the Broker,
and I

12
00:00:35,580 --> 00:00:37,550
talked about how Broker is a pattern
that's used

13
00:00:37,550 --> 00:00:44,040
to shield clients from communication
mechanisms and infrastructure concerns.

14
00:00:44,040 --> 00:00:47,460
When they talk to services implemented in
servers, which

15
00:00:47,460 --> 00:00:50,695
typically run in processes either, either
on the same machine

16
00:00:50,695 --> 00:00:53,120
or in a separate machine, and we talked
about how

17
00:00:53,120 --> 00:00:55,840
the Broker takes care of all the low level
details.

18
00:00:55,840 --> 00:00:58,400
Things like connection management, data

19
00:00:58,400 --> 00:01:03,420
transfer protocols, concurrency control,
synchronization,

20
00:01:03,420 --> 00:01:07,350
threading, some fault tolerance thrown in
there, memory management, all

21
00:01:07,350 --> 00:01:10,270
that kind of good stuff, that low level
stuff, is sort

22
00:01:10,270 --> 00:01:14,290
of hidden from you and encapsulated by the
underlying Broker mechanisms.

23
00:01:14,290 --> 00:01:17,720
And, so we talked last time about the good
and the bad about the Brokers.

24
00:01:17,720 --> 00:01:20,330
And sort of the applicability and so on.

25
00:01:20,330 --> 00:01:21,530
And now what we're going to do is we're

26
00:01:21,530 --> 00:01:24,140
going to talk about how you might
implement a Broker.

27
00:01:24,140 --> 00:01:25,820
And of course, we're going to do it in the
context of Android.

28
00:01:26,820 --> 00:01:28,190
So one of the first things you need to do
is

29
00:01:28,190 --> 00:01:31,930
figure out what is your invocation
interface going to look like?

30
00:01:31,930 --> 00:01:34,570
Now, there's a couple of different ways to
ask this

31
00:01:34,570 --> 00:01:37,730
question, and one way to ask the question
is what's the

32
00:01:37,730 --> 00:01:41,000
client application's interface going to
look like, and do you

33
00:01:41,000 --> 00:01:44,350
want to make it as transparent as possible
from the client?

34
00:01:44,350 --> 00:01:48,090
So, if you want transparency, you're
going to want to use some Broker, or

35
00:01:48,090 --> 00:01:50,850
some proxy like mechanisms, and we're
going to get to that in a second.

36
00:01:50,850 --> 00:01:53,740
What I'm thinking about here is a little
bit lower level than that.

37
00:01:53,740 --> 00:01:56,830
It's, what's the interface that a proxy,
or

38
00:01:56,830 --> 00:01:58,870
an application that wants to program a
little

39
00:01:58,870 --> 00:02:03,980
closer to the metal, going to use in order
to pass something to the Broker itself.

40
00:02:03,980 --> 00:02:07,130
So how does a client invoke an operation
on the Broker?

41
00:02:07,130 --> 00:02:10,130
And so, basically what we're going to do
is

42
00:02:10,130 --> 00:02:11,710
come up with a way to allow somebody,
either

43
00:02:11,710 --> 00:02:14,310
the client or the client's proxy, to pass

44
00:02:14,310 --> 00:02:17,590
a message from the client over to the
server.

45
00:02:17,590 --> 00:02:21,970
And if you take a look here, you can see
the way this is done in Android, is

46
00:02:21,970 --> 00:02:27,410
something that's actually provided for
the, by the underlying infrastructure,

47
00:02:27,410 --> 00:02:33,950
it's this, this transact method, and
transact is, is used to send the data.

48
00:02:33,950 --> 00:02:37,820
It's, it's something that's exposed by the
binder class, which is the

49
00:02:37,820 --> 00:02:39,610
lower level mechanisms that does
communication

50
00:02:39,610 --> 00:02:41,730
in Android, a lower level mechanism.

51
00:02:41,730 --> 00:02:44,630
There's lower levels in the binder, we'll
talk about in a minute.

52
00:02:44,630 --> 00:02:48,600
But basically it provides a method called
transact, and you call transact with

53
00:02:48,600 --> 00:02:52,030
the code, which is basically the method
that you're calling, as well as

54
00:02:52,030 --> 00:02:55,850
a parcel that contains the data that you
want to have sent to

55
00:02:55,850 --> 00:03:00,730
the server, as well as how you want the
reply information to come back.

56
00:03:00,730 --> 00:03:04,800
And so that information, plus some other
flags, are actually used to send the data.

57
00:03:04,800 --> 00:03:07,780
And when you call, when somebody calls
transact,

58
00:03:07,780 --> 00:03:10,230
which turns out typically to be the proxy.

59
00:03:10,230 --> 00:03:13,230
Calls it under the hood and it ends up
calling the on

60
00:03:13,230 --> 00:03:17,490
transact method, and that will get
delivered over to the server side, and

61
00:03:17,490 --> 00:03:21,220
there's an on transact method that gets
called back on the stub,

62
00:03:21,220 --> 00:03:24,180
and that's how the data gets up called to
the, to the server.

63
00:03:24,180 --> 00:03:26,420
We'll talk about that in a second.

64
00:03:26,420 --> 00:03:30,015
If you take a look at the binder code in
Android, if you take a look at

65
00:03:30,015 --> 00:03:33,030
binder.java, you'll see this
implementation and it looks

66
00:03:33,030 --> 00:03:34,220
more or less like what I've shown you
here.

67
00:03:35,920 --> 00:03:39,630
The next thing you need to do is you need
to select and implement the marshaller.

68
00:03:39,630 --> 00:03:41,640
If you recall, there were sort of three or

69
00:03:41,640 --> 00:03:43,570
four main things you have in the Broker
pattern.

70
00:03:43,570 --> 00:03:45,760
You've got the client, obviously.

71
00:03:45,760 --> 00:03:47,390
You've got a requester, which is the

72
00:03:47,390 --> 00:03:50,240
client side part that invokes an
operation.

73
00:03:50,240 --> 00:03:53,170
You have the marshaller, or demarshaller,
which

74
00:03:53,170 --> 00:03:55,740
is responsible for serializing and
unserializing the

75
00:03:55,740 --> 00:03:57,510
messages, and you have this thing called

76
00:03:57,510 --> 00:04:00,180
the dispatcher, and those are the key
pieces.

77
00:04:00,180 --> 00:04:03,320
And that's responsible for dispatching the
request to

78
00:04:03,320 --> 00:04:05,630
the servant, which is what actually
implements things.

79
00:04:05,630 --> 00:04:09,190
So, the marshaller has different pieces to
it but, this

80
00:04:09,190 --> 00:04:11,950
is typically what's handled for you by the
proxy pattern,

81
00:04:11,950 --> 00:04:14,900
so I'm not going to talk a lot about here
because

82
00:04:14,900 --> 00:04:17,450
we just covered that in length in the
proxy discussion.

83
00:04:17,450 --> 00:04:22,880
But in a nutshell as you all know, the
AIBL compiler generates the code to

84
00:04:22,880 --> 00:04:28,016
do the proxy operations and it basically
takes a look at the data types you

85
00:04:28,016 --> 00:04:33,410
define in the AIBL interface, and then it
creates the appropriate calls to the lower

86
00:04:33,410 --> 00:04:36,210
level Java code to marshal and demarshal

87
00:04:36,210 --> 00:04:40,760
things from native data types into these
parcels.

88
00:04:40,760 --> 00:04:43,180
So as you can see here, for example, if
we're

89
00:04:43,180 --> 00:04:46,224
using our download image stuff, then
there's going to be

90
00:04:46,224 --> 00:04:49,018
this write string call here, which is
going to go

91
00:04:49,018 --> 00:04:51,651
ahead and take the, the URL, the URI or
whatnot.

92
00:04:51,651 --> 00:04:57,164
Oops, that should be URI and it's going to
go ahead and write that

93
00:04:57,164 --> 00:05:02,775
thing into the parcel, and then the parcel
will be passed over as part

94
00:05:02,775 --> 00:05:08,124
of the invocation with the transact method
on the remote binder.

95
00:05:08,124 --> 00:05:10,463
So we've already covered a lot of that
stuff but what we're about to

96
00:05:10,463 --> 00:05:12,940
cover though now is a little bit deeper
than what we covered with proxy.

97
00:05:12,940 --> 00:05:16,900
Proxy kind of stops at the point where
things start to get interesting.

98
00:05:16,900 --> 00:05:19,640
So proxy is responsible for turning a
method call into

99
00:05:19,640 --> 00:05:22,630
a message of some kind, a parcel in
Android's case.

100
00:05:22,630 --> 00:05:24,530
But then it has to deliver that parcel
somehow.

101
00:05:24,530 --> 00:05:25,740
How does it get there?

102
00:05:25,740 --> 00:05:26,880
Well, there has to be some kind

103
00:05:26,880 --> 00:05:30,610
of protocol to communicate between sender
and receiver.

104
00:05:30,610 --> 00:05:35,110
And, inevitably, these protocols typically
use some kind of low level,

105
00:05:35,110 --> 00:05:37,140
byte screen or record oriented

106
00:05:37,140 --> 00:05:40,660
communication mechanism, some type of
transport.

107
00:05:40,660 --> 00:05:44,520
There's different choices, different
middleware cakes that implements Brokers.

108
00:05:44,520 --> 00:05:46,146
Some dataware uses datagrams or

109
00:05:46,146 --> 00:05:48,856
connectionless communications where you
don't set

110
00:05:48,856 --> 00:05:51,924
up a channel, or you don't setup state and
send and receiver

111
00:05:51,924 --> 00:05:54,690
ahead of time, you just send the data out
and you either

112
00:05:54,690 --> 00:05:57,670
assume it gets there, or you don't care if
it gets there.

113
00:05:57,670 --> 00:06:00,240
Or you have some kind of retransmission
protocol that is

114
00:06:00,240 --> 00:06:01,940
used at a higher level to make it get
there.

115
00:06:01,940 --> 00:06:03,980
That's conectionless communication.

116
00:06:03,980 --> 00:06:05,790
Android doesn't do that.

117
00:06:05,790 --> 00:06:10,640
Much more common in certain kinds of
middleware, especially object oriented or,

118
00:06:11,660 --> 00:06:14,300
not object oriented procedure call
environments,

119
00:06:14,300 --> 00:06:17,460
is to use connection oriented protocols.

120
00:06:17,460 --> 00:06:19,840
So the classic example of a connection
oriented protocol

121
00:06:19,840 --> 00:06:23,140
would be something like TCP/IP, where it
sets up

122
00:06:23,140 --> 00:06:26,010
a connection and establishes state on both
the sender

123
00:06:26,010 --> 00:06:29,080
and receiver, and then the data begins to
flow.

124
00:06:29,080 --> 00:06:36,460
Does anybody know why TCP/IP sets up state
on the sender and receiver, and the kernel

125
00:06:36,460 --> 00:06:39,060
of the sender receiver protocol machines,
prior to

126
00:06:39,060 --> 00:06:41,010
starting to try to deliver the actual
data.

127
00:06:42,140 --> 00:06:44,937
What's, what's the reason why the state
is, is setup?

128
00:06:48,160 --> 00:06:50,000
First of all, does anybody know what
TCP/IP does?

129
00:06:52,220 --> 00:06:57,258
Can someone explain to me what TCP/IP
does?

130
00:06:57,258 --> 00:07:01,570
>> It establishes a handshake between two
endpoints.

131
00:07:01,570 --> 00:07:02,778
>> Right handshake to handshake is

132
00:07:02,778 --> 00:07:04,890
established, but whats, whats the
handshake doing?

133
00:07:04,890 --> 00:07:05,939
What's it, what's it getting you?

134
00:07:05,939 --> 00:07:06,869
Why, why do we need it?

135
00:07:06,869 --> 00:07:07,965
Or, what-

136
00:07:07,965 --> 00:07:08,816
>> Sequence numbers.

137
00:07:08,816 --> 00:07:10,441
[INAUDIBLE].

138
00:07:10,441 --> 00:07:12,880
>> Right, exactly, reliability is the
reason.

139
00:07:12,880 --> 00:07:15,089
So, if both sides understand the data that
will

140
00:07:15,089 --> 00:07:16,911
be past, then they can keep track to see

141
00:07:16,911 --> 00:07:19,122
if anything got dropped along the way by
keeping

142
00:07:19,122 --> 00:07:22,320
track of sequence numbers and
acknowledgements and so on.

143
00:07:22,320 --> 00:07:24,570
And by exchanging that information ahead
of time and kind

144
00:07:24,570 --> 00:07:28,390
of presynchronizing them, the starting
sequence numbers and so on, then

145
00:07:28,390 --> 00:07:31,120
it makes it possible to not only route the
information more

146
00:07:31,120 --> 00:07:33,600
efficiently, but also to be able to do it
more reliably.

147
00:07:33,600 --> 00:07:36,800
So if something gets dropped, the receiver
knows

148
00:07:36,800 --> 00:07:39,020
it was expecting it and it didn't get it.

149
00:07:39,020 --> 00:07:41,270
And so, there's a protocol that goes back
and forth

150
00:07:41,270 --> 00:07:43,252
to try to retransmit the data if it gets
dropped.

151
00:07:43,252 --> 00:07:45,735
And there's a whole bunch of other things
that get added to

152
00:07:45,735 --> 00:07:48,862
TCP/IP to make it work in a variety of
different [UNKNOWN] products.

153
00:07:48,862 --> 00:07:52,920
So that gives you reliability, that's what
we use for the internet.

154
00:07:52,920 --> 00:07:55,960
In Android, we use a little bit lower
level mechanism that's implemented

155
00:07:55,960 --> 00:08:00,160
as part of the OS kernel by something
called the binder driver.

156
00:08:00,160 --> 00:08:02,610
And the binder driver is more of a

157
00:08:02,610 --> 00:08:05,672
proprietary proprietary's the wrong word,
kind of a

158
00:08:05,672 --> 00:08:10,250
purposed, customized protocol design for
high performance communication

159
00:08:10,250 --> 00:08:14,070
between processes that run on the same
machine.

160
00:08:14,070 --> 00:08:17,218
And, under the hood, it's implemented with
some low

161
00:08:17,218 --> 00:08:21,900
level system calls called IOCTL's, or
I-O-C-T-Ls, IO controls.

162
00:08:21,900 --> 00:08:24,530
And there's a bunch of different sort of

163
00:08:24,530 --> 00:08:26,560
header information that gets passed back
and forth.

164
00:08:26,560 --> 00:08:28,360
There's certain flags that get sent.

165
00:08:28,360 --> 00:08:29,840
This thing called binder.

166
00:08:29,840 --> 00:08:32,275
Write and read is the flag that's passed
into the

167
00:08:32,275 --> 00:08:36,340
IOCTL to inform that data is being sent
back and forth.

168
00:08:36,340 --> 00:08:39,550
There's also a struct called binder
transaction data,

169
00:08:39,550 --> 00:08:41,270
that keeps track of a bunch of fields.

170
00:08:41,270 --> 00:08:44,590
Things like what the buffer is that
contains the bytes

171
00:08:44,590 --> 00:08:47,720
and some other information that is used by
the lower level.

172
00:08:47,720 --> 00:08:51,300
A binder driver transport to move the
information back and forth.

173
00:08:51,300 --> 00:08:53,500
And so that's kind of what's going on
under the hood.

174
00:08:53,500 --> 00:08:55,860
This is not something you would typically
use

175
00:08:55,860 --> 00:08:58,990
in a network environment, it's really
intended for

176
00:08:58,990 --> 00:09:01,980
the relatively low latency back plane that
you

177
00:09:01,980 --> 00:09:04,290
would find if you're running in the same
device.

178
00:09:04,290 --> 00:09:07,300
It's sort of optimized for that kind of,
kind of world.

179
00:09:07,300 --> 00:09:09,290
There's a nice paper that you could read
about, or

180
00:09:09,290 --> 00:09:11,480
a nice presentation that I have a link for
here

181
00:09:11,480 --> 00:09:13,350
that gives a lot more information about
the low level

182
00:09:13,350 --> 00:09:16,710
details of how the binder driver is
implemented in Android.

183
00:09:16,710 --> 00:09:19,990
It's actually part of the Android Linux
kernel extensions.

184
00:09:21,370 --> 00:09:23,650
Now, the next thing I'm going to talk
about here, I colored it

185
00:09:23,650 --> 00:09:28,060
red because it doesn't apply directly to
Android but, most Broker implementations

186
00:09:28,060 --> 00:09:31,320
are running in, or many Broker
implementations are actually running in a

187
00:09:31,320 --> 00:09:33,690
network environment, not a stand alone

188
00:09:33,690 --> 00:09:36,140
back playing connected by a bus
environment.

189
00:09:36,140 --> 00:09:38,740
So if that's the case, you have to have
some kind of network communication.

190
00:09:38,740 --> 00:09:41,580
And there's a bunch of things you need to
think about in that case,

191
00:09:41,580 --> 00:09:46,590
about the protocols you use to talk across
the network, which are often TCP/IP based.

192
00:09:46,590 --> 00:09:48,990
And then other, just mechanisms you might
want to add.

193
00:09:48,990 --> 00:09:52,260
Things like acceptors and connectors and,
reactors and so on.

194
00:09:52,260 --> 00:09:53,990
And, and these are things we're not really

195
00:09:53,990 --> 00:09:57,140
going to cover here because Android
doesn't have that capability.

196
00:09:57,140 --> 00:10:02,670
But if you start studying networked
communication, and networked programming

197
00:10:02,670 --> 00:10:08,760
environments, things like ACE, or Python's
Twisted, or other parts of Java like

198
00:10:08,760 --> 00:10:11,840
Jedi and Neti and so on, you'll find lots
of examples of

199
00:10:11,840 --> 00:10:15,780
these kinds of patterns used as part of
the network communication layers.

200
00:10:15,780 --> 00:10:17,010
But we're not going to really cover them
right now.

201
00:10:18,280 --> 00:10:19,920
The next thing you have to think about if
you're trying to

202
00:10:19,920 --> 00:10:25,020
build a Broker is think through the issues
related to resource management.

203
00:10:25,020 --> 00:10:27,670
So, resource management is an important
part of any

204
00:10:27,670 --> 00:10:29,970
system, especially as it scales because
you want to make sure

205
00:10:29,970 --> 00:10:32,950
that these resources that are in high
demand, but

206
00:10:32,950 --> 00:10:38,350
somewhat scarce supply, are properly
allocated and de-allocated by something.

207
00:10:38,350 --> 00:10:41,230
The operating system, the middleware or
some combination.

208
00:10:41,230 --> 00:10:44,900
And the key point here is that you don't
have an infinite amount of this stuff.

209
00:10:44,900 --> 00:10:46,730
What are some good examples of resources
that

210
00:10:46,730 --> 00:10:48,660
you don't really have an infinite amount
of?

211
00:10:48,660 --> 00:10:53,200
In, in the context of a Broker or some
kind of communications system.

212
00:10:55,880 --> 00:10:56,710
>> Ports?

213
00:10:56,710 --> 00:10:57,330
>> Ports.

214
00:10:57,330 --> 00:10:58,060
Great, great example.

215
00:10:58,060 --> 00:11:02,450
So ports are typically end points of
communication

216
00:11:02,450 --> 00:11:04,040
that queue up data that goes to them.

217
00:11:04,040 --> 00:11:06,000
They're, it's, they're addressable
somehow.

218
00:11:06,000 --> 00:11:08,510
And you don't have an unlimited number of
ports, you'll eventually run out.

219
00:11:08,510 --> 00:11:10,690
Of course, why do you eventually run out
of ports?

220
00:11:11,860 --> 00:11:14,060
But what's the other resource that you
only have

221
00:11:14,060 --> 00:11:15,350
so much of before you run out of it?

222
00:11:16,380 --> 00:11:16,670
>> Memory?

223
00:11:16,670 --> 00:11:17,020
>> Memory, right.

224
00:11:17,020 --> 00:11:18,100
So there's only so much memory.

225
00:11:18,100 --> 00:11:19,350
So you have to manage memory.

226
00:11:19,350 --> 00:11:22,130
You have to memory, mem, manage ports.

227
00:11:22,130 --> 00:11:23,720
Other things you typically want to manage
would

228
00:11:23,720 --> 00:11:26,540
be connections, which are often related to
ports.

229
00:11:26,540 --> 00:11:28,180
Threads, that's a big issue.

230
00:11:28,180 --> 00:11:30,430
You don't want to have, you know, you
don't want to start spawning

231
00:11:30,430 --> 00:11:33,520
threads just endlessly, because you will
quickly run out of them.

232
00:11:33,520 --> 00:11:35,630
And if you don't run out of them, you'll
run out of

233
00:11:35,630 --> 00:11:38,820
memory and then you'll have all kinds of
thrashing and props like that.

234
00:11:38,820 --> 00:11:40,940
So, there's a bunch of different patterns
that people

235
00:11:40,940 --> 00:11:44,940
have used over time to implement effective
resource management.

236
00:11:44,940 --> 00:11:46,290
And, these are protocols.

237
00:11:46,290 --> 00:11:47,810
These are services and so on.

238
00:11:47,810 --> 00:11:49,570
So some examples that you might want to
use in the

239
00:11:49,570 --> 00:11:54,080
context of a Broker would be things like
caching and pooling.

240
00:11:54,080 --> 00:11:57,570
Which at first glance sounds similar, but
they have a little bit different purpose.

241
00:11:57,570 --> 00:12:02,500
So oftentimes, we use caching on the
client side in order

242
00:12:02,500 --> 00:12:07,680
to have information held open, even if
it's not currently being used.

243
00:12:07,680 --> 00:12:10,520
So a good example of a cache might be some
kind of connection cache.

244
00:12:10,520 --> 00:12:15,400
Where you might share a connection to a
server, and as

245
00:12:15,400 --> 00:12:18,740
you allocate those connections, you might
cache them on the client.

246
00:12:18,740 --> 00:12:20,300
So, if you have multiple threads that are
trying

247
00:12:20,300 --> 00:12:23,590
to write, they can share access to the
cached connection.

248
00:12:23,590 --> 00:12:25,770
So that's one example of something.

249
00:12:25,770 --> 00:12:26,990
A pool might be something like a pool

250
00:12:26,990 --> 00:12:29,750
of threads, where you preallocate a bunch
of threads.

251
00:12:29,750 --> 00:12:31,800
You have them running say on the server
side.

252
00:12:31,800 --> 00:12:35,630
And when a request comes in, the incoming
binder driver picks a

253
00:12:35,630 --> 00:12:38,220
thread out of the pool and gives it the
work to do.

254
00:12:38,220 --> 00:12:41,220
So pooling and caching are really both
designed in

255
00:12:41,220 --> 00:12:47,360
order to preallocate and or allocate and
remain allocated resources

256
00:12:47,360 --> 00:12:49,560
so that things don't have to be set up and

257
00:12:49,560 --> 00:12:54,480
torn down from scratch every time, thereby
improving overall throughput.

258
00:12:54,480 --> 00:12:56,090
So a good, good quiz question would be

259
00:12:56,090 --> 00:12:58,580
what are some examples of resource
management and

260
00:12:58,580 --> 00:13:00,180
what do they buy you, in the context

261
00:13:00,180 --> 00:13:01,669
of the Broker pattern, or something like
that.

262
00:13:03,300 --> 00:13:05,820
There's some publications you can see
these appeared in a POSA3 book.

263
00:13:05,820 --> 00:13:09,290
You can also take a look at them on the
website

264
00:13:09,290 --> 00:13:11,910
of the authors of the POSA3 book talk
about pooling and caching.

265
00:13:13,870 --> 00:13:16,760
Another thing that you need is some kind
of registration interface that's

266
00:13:16,760 --> 00:13:21,990
used by the dispatcher to be able to
register and unregister servants.

267
00:13:21,990 --> 00:13:23,990
Servants, keep in mind, are the things
that actually

268
00:13:23,990 --> 00:13:28,650
get requests dispatched to them, by the
underlying Broker middleware.

269
00:13:28,650 --> 00:13:32,930
So, in the context of general purpose
distribute computing people

270
00:13:32,930 --> 00:13:36,350
have defined things like object adapters
to do this kind of stuff.

271
00:13:36,350 --> 00:13:41,020
In the context of Android, we have
something that's called, the binder.

272
00:13:41,020 --> 00:13:45,400
And one of the methods that the binder
defines is called attatchInterface.

273
00:13:45,400 --> 00:13:48,680
And you pass into that some information
about the interface, and

274
00:13:48,680 --> 00:13:51,840
this gets stashed away so you're, you're
able to know about

275
00:13:51,840 --> 00:13:53,400
it and you can find a way to get back to

276
00:13:53,400 --> 00:13:56,750
it later when you need to do call backs on
it.

277
00:13:56,750 --> 00:13:58,810
And you can take a look, all of the source
code is available here.

278
00:14:00,470 --> 00:14:02,000
Another thing we need to be able to do, if
we

279
00:14:02,000 --> 00:14:05,250
want to implement a Broker, is figure out
some way of being able

280
00:14:05,250 --> 00:14:09,090
to communicate between the client and the
server, so the client

281
00:14:09,090 --> 00:14:15,190
gets access to the servants that the
server is managing and owning.

282
00:14:15,190 --> 00:14:17,830
So how do, how do you communicate that
information back and forth?

283
00:14:17,830 --> 00:14:19,900
There's lots and lots of different ways to
do this.

284
00:14:19,900 --> 00:14:23,410
In more traditional distributed Broker
environments, you typically

285
00:14:23,410 --> 00:14:26,160
use some kind of naming service, or some
kind

286
00:14:26,160 --> 00:14:28,690
of dictionary or directory service to be
able

287
00:14:28,690 --> 00:14:32,830
to map names to object references or
something else.

288
00:14:32,830 --> 00:14:37,140
And that's needed because we oftentimes
need to look these things up more like you

289
00:14:37,140 --> 00:14:40,880
would search things with a Google search,
you want to type in a bunch of properties,

290
00:14:40,880 --> 00:14:43,900
and then you get back a bunch of options
and you choose one or more

291
00:14:43,900 --> 00:14:47,890
of them to, to invoke, in the case of
Android, it's a little bit different.

292
00:14:47,890 --> 00:14:49,230
It's a little bit more tightly coupled.

293
00:14:49,230 --> 00:14:53,090
So, there's a protocol that's defined here
that has a couple of parts to it.

294
00:14:53,090 --> 00:14:57,970
One part is the onBind factory method
that's

295
00:14:57,970 --> 00:15:03,460
defined by the server who implements the
binder object, and that is responsible

296
00:15:03,460 --> 00:15:06,410
for giving back to the caller, which is
ultimately going

297
00:15:06,410 --> 00:15:11,160
to be the client an, reference, an iBinder
to the binder.

298
00:15:11,160 --> 00:15:15,140
So iBinder is interfaced to a binder and
you can use it to invoke operations.

299
00:15:15,140 --> 00:15:19,910
And you can take a look at the service
interface to find out more about that.

300
00:15:19,910 --> 00:15:23,590
The other thing is to find on the client's
side is a

301
00:15:23,590 --> 00:15:30,240
hook method called onServiceConnected to
get this binder back from the server.

302
00:15:30,240 --> 00:15:34,680
Or the service, and then stash it away
someplace on the client side, so it's

303
00:15:34,680 --> 00:15:36,450
available for being used to invoke these

304
00:15:36,450 --> 00:15:38,560
two way operations, or one way operations
later.

305
00:15:38,560 --> 00:15:41,800
So there's kind of this multistep
protocol, as you

306
00:15:41,800 --> 00:15:44,760
may recall, where you do a bind service

307
00:15:44,760 --> 00:15:46,430
that causes on bind to get called on

308
00:15:46,430 --> 00:15:50,470
the server that passes you back, a binder,
object.

309
00:15:50,470 --> 00:15:53,390
That binder object comes back to you
through onServiceConnected.

310
00:15:53,390 --> 00:15:54,850
The hook method.

311
00:15:54,850 --> 00:15:57,620
You get that thing and then you can use it
to invoke operations.

312
00:15:57,620 --> 00:16:02,034
So that's how Android gets the information
back to the, to the client.

313
00:16:02,034 --> 00:16:03,692
And you can take a look here, for

314
00:16:03,692 --> 00:16:07,080
much more information about the service
connection interface.

315
00:16:09,080 --> 00:16:11,230
Another thing we need is some kind a
mechanism

316
00:16:11,230 --> 00:16:14,450
to be able to transform these request
messages that

317
00:16:14,450 --> 00:16:17,670
are coming in from the requester into up
calls

318
00:16:17,670 --> 00:16:22,140
that are dispatched on a method defined by
our servant.

319
00:16:22,140 --> 00:16:24,630
Now, keep in mind in, in the case of
Android, the servant

320
00:16:24,630 --> 00:16:28,655
is basically whatever, typically
anonymous, object

321
00:16:28,655 --> 00:16:32,340
subclassed anonymously from stub, and then
fills

322
00:16:32,340 --> 00:16:35,270
in the various methods that have been
defined on that stub in

323
00:16:35,270 --> 00:16:40,030
order to carry out the work that was
described in the AIDL interface.

324
00:16:40,030 --> 00:16:42,660
So, in this particular case, this is
handled by the stub.

325
00:16:42,660 --> 00:16:45,280
When the generated stub comes out, it has

326
00:16:45,280 --> 00:16:49,270
a, an onTransact method, and that
onTransact method will

327
00:16:49,270 --> 00:16:52,570
take a look at the particular code that
was

328
00:16:52,570 --> 00:16:57,310
passed over by the transmit, or the
transact call.

329
00:16:57,310 --> 00:17:00,250
And that transact call will then end up

330
00:17:00,250 --> 00:17:03,950
dispatching the onTransact callback, which
looks at the

331
00:17:03,950 --> 00:17:07,920
code, which tells it how to demarshall the

332
00:17:07,920 --> 00:17:11,870
various fields that are passed over in the
parcel.

333
00:17:11,870 --> 00:17:16,090
And then that's turned into native data
types, in this case, which

334
00:17:16,090 --> 00:17:21,220
are then passed to the up call method, to
the actual servant implementation.

335
00:17:21,220 --> 00:17:26,930
In this case, we are doing the download
image method for our download interface.

336
00:17:26,930 --> 00:17:27,740
Our download interface.

337
00:17:27,740 --> 00:17:30,790
So that just gives you a sense of how
those things fit together.

338
00:17:30,790 --> 00:17:32,870
So that kind of illustrates all the
different pieces that

339
00:17:32,870 --> 00:17:36,410
are involved, a client invokes a method on
a proxy, the

340
00:17:36,410 --> 00:17:41,010
proxy turns the method into a message,
calls the transact method

341
00:17:41,010 --> 00:17:45,250
to pass it down to the Broker, through the
requester portion.

342
00:17:45,250 --> 00:17:47,520
The requester sends it across using

343
00:17:47,520 --> 00:17:50,260
that binder driver communication protocol,
comes up

344
00:17:50,260 --> 00:17:54,700
on the receiver side, the dispatcher
receives the request, takes a look at

345
00:17:54,700 --> 00:17:58,600
it, figures out who it's for using the
lookup mechanisms that were defined

346
00:17:58,600 --> 00:18:01,100
by the registration interface we looked
at,

347
00:18:01,100 --> 00:18:03,680
and then ultimately, finds the right stub.

348
00:18:03,680 --> 00:18:07,250
And then invokes the operation on that
stub to go ahead and, and

349
00:18:07,250 --> 00:18:10,950
call back on the, the servant's
implementation method to get the job done.

350
00:18:10,950 --> 00:18:12,420
So that's kind of the steps involved.

351
00:18:12,420 --> 00:18:13,900
And then there's also a reverse order

352
00:18:13,900 --> 00:18:15,550
going the other direction if there's a
reply.

353
00:18:17,170 --> 00:18:19,660
Something else you need to do if you want
to start implementing Broker is

354
00:18:19,660 --> 00:18:21,250
figure out whether or not you're going to

355
00:18:21,250 --> 00:18:25,160
support asynchrony, or just simply stick
with synchrony.

356
00:18:25,160 --> 00:18:28,860
Traditional Brokers tended to only support
synchronous communication, because

357
00:18:28,860 --> 00:18:33,400
they were trying to mimic two way,
procedure call interfaces.

358
00:18:33,400 --> 00:18:36,120
So, a regular procedure call is a two way
call.

359
00:18:36,120 --> 00:18:40,570
So, for many years, remote procedure calls
were kind of two way calls.

360
00:18:40,570 --> 00:18:42,520
And early versions of Corba were like that
too.

361
00:18:42,520 --> 00:18:43,990
If you didn't like that, you used kind of

362
00:18:43,990 --> 00:18:46,280
one way calls, but that had some down
sides.

363
00:18:46,280 --> 00:18:48,720
Later on, people began to realize, this is
kind of limited.

364
00:18:48,720 --> 00:18:50,890
We really want to support asynchrony as a
first

365
00:18:50,890 --> 00:18:54,550
class citizen in the type system of the
Broker.

366
00:18:54,550 --> 00:18:56,520
And so people started adding new support
to that.

367
00:18:56,520 --> 00:18:57,701
In Corba they have something

368
00:18:57,701 --> 00:19:00,230
call asynchronous method invocation for
example.

369
00:19:00,230 --> 00:19:02,720
And asynchronous method handling, which
are used to

370
00:19:02,720 --> 00:19:05,750
be able to give you better support for
asynchroni.

371
00:19:05,750 --> 00:19:09,300
Microsoft Com has something similar, along
those lines as well.

372
00:19:09,300 --> 00:19:14,185
In Android, they don't really build it
indirectly, but you can do it, by pattern

373
00:19:14,185 --> 00:19:20,090
convention, where you pass a callback
object to the, via a one

374
00:19:20,090 --> 00:19:25,850
way operation on the the interface, the
ideal interface that goes to the server.

375
00:19:25,850 --> 00:19:27,880
That callback object is stashed away
somewhere

376
00:19:27,880 --> 00:19:29,850
and then is used later, either in the

377
00:19:29,850 --> 00:19:34,220
same thread or some other thread, to
invoke a one way call back to the client.

378
00:19:34,220 --> 00:19:35,300
So you have to decide how to do it.

379
00:19:35,300 --> 00:19:39,590
Android doesn't really give you a lot of
sophisticated support for this, but

380
00:19:39,590 --> 00:19:42,848
it is possible to do it, and I find it a
very useful feature.

381
00:19:42,848 --> 00:19:46,956
And then the last thing to think about if
you're trying to implement a Broker,

382
00:19:46,956 --> 00:19:51,375
obviously there's more stuff than this,
but this is the key things to think about,

383
00:19:51,375 --> 00:19:55,483
is whether or not you want to try to do
colocation optimizations for cases where

384
00:19:55,483 --> 00:19:57,974
you're invoking a method on something
that's

385
00:19:57,974 --> 00:20:00,800
in the same address space as the caller.

386
00:20:00,800 --> 00:20:03,776
So if you end up having your servant in
the same address base

387
00:20:03,776 --> 00:20:07,447
as your client, you want to do something
to, to match those things up.

388
00:20:07,447 --> 00:20:10,239
And as you can see, the generated methods
called

389
00:20:10,239 --> 00:20:13,307
as interface actually have some checks to
see whether

390
00:20:13,307 --> 00:20:15,828
or not the call that's coming in is
actually

391
00:20:15,828 --> 00:20:19,190
resolvable in the same address space as
the client.

392
00:20:19,190 --> 00:20:23,880
And if it is, it just returns back the,
the interface directly to the

393
00:20:23,880 --> 00:20:27,040
caller, and you can invoke a method call
that goes straight to that thing.

394
00:20:27,040 --> 00:20:31,164
If it's not colocated in the same address
base, then it ends up making a

395
00:20:31,164 --> 00:20:33,502
proxy and returning the proxy, and when

396
00:20:33,502 --> 00:20:36,184
the proxy's called, that does all the
things

397
00:20:36,184 --> 00:20:40,653
the proxy does, due to marshalling of the
data and then the transmission of it

398
00:20:40,653 --> 00:20:43,612
through the binder mechanism and the
binder driver

399
00:20:43,612 --> 00:20:45,868
and so on, over to the receiver side.

400
00:20:45,868 --> 00:20:48,945
Any questions about any of that?

401
00:20:48,945 --> 00:20:52,198
Some more information here at this link
about colocation optimizations, just

402
00:20:52,198 --> 00:20:55,120
talking about the overall concept and
showing the speed ups involved.

403
00:20:56,650 --> 00:21:00,550
So now that we've kind of seen the Broker
pattern implemented

404
00:21:00,550 --> 00:21:03,540
in various steps and kind of walked
through how Android does

405
00:21:03,540 --> 00:21:06,330
it under the hood, let's give some
examples of some

406
00:21:06,330 --> 00:21:11,630
pretty cool sophisticated uses of the
Broker pattern in Android itself.

407
00:21:11,630 --> 00:21:15,550
So this particular example uses the
network settings activity, you

408
00:21:15,550 --> 00:21:18,090
can see here thanks to Kristof, we have a
screen

409
00:21:18,090 --> 00:21:22,270
shot that he, managed to purloin through
torturous path to

410
00:21:22,270 --> 00:21:24,800
get a screen shot of what this app looks
like.

411
00:21:24,800 --> 00:21:27,792
And basically what it does is it goes out
and it searches

412
00:21:27,792 --> 00:21:32,281
for cellular networks, like, you know,
CDMA or GSM or multiple providers which

413
00:21:32,281 --> 00:21:35,598
you may or may not have, depending on what
kind of service you

414
00:21:35,598 --> 00:21:40,720
have, if it's locked, unlocked, carrier
provided, where you are and so on.

415
00:21:40,720 --> 00:21:42,400
But basically here's what it does.

416
00:21:42,400 --> 00:21:46,040
There's a activity side of this thing
called network settings,

417
00:21:46,040 --> 00:21:51,060
and that invokes start service, and that
causes the causes the

418
00:21:51,060 --> 00:21:55,410
activity manager service to go ahead and
start up the network

419
00:21:55,410 --> 00:21:59,050
query service using the activator pattern
that we talked about before.

420
00:21:59,050 --> 00:22:00,050
And then that goes ahead and

421
00:22:00,050 --> 00:22:03,865
initializes the it initializes that
particular service.

422
00:22:03,865 --> 00:22:06,970
[COUGH] And then here's kind of the quirky
part.

423
00:22:06,970 --> 00:22:10,220
Right after it calls start service, the
network settings

424
00:22:10,220 --> 00:22:13,400
activity, then makes a call to bind
service, which

425
00:22:13,400 --> 00:22:15,120
is a little weird because it's, it's kind
of

426
00:22:15,120 --> 00:22:18,840
this Frankenstein monster that's a little
bit of both worlds.

427
00:22:18,840 --> 00:22:20,900
It's a started service, that our, the

428
00:22:20,900 --> 00:22:23,185
network query service is what they started
service

429
00:22:23,185 --> 00:22:25,325
because start service was called, and a

430
00:22:25,325 --> 00:22:27,980
bound service, because bind service was
called on.

431
00:22:27,980 --> 00:22:31,900
And the basic idea, the basic reason that
they did this, does anyone want to

432
00:22:31,900 --> 00:22:34,700
hazard a guess as to the reason why they
actually did it this way?

433
00:22:34,700 --> 00:22:35,670
What was the reason?

434
00:22:35,670 --> 00:22:37,450
Blows the motivation for this in Android.

435
00:22:40,930 --> 00:22:41,430
Yes, sir?

436
00:22:42,500 --> 00:22:45,330
>> Do bound services die when there's
nobody else that's bound to it?

437
00:22:45,330 --> 00:22:47,300
Or if you start it first, then it's a
started

438
00:22:47,300 --> 00:22:49,660
service so it's not going to die unless it
has to?

439
00:22:49,660 --> 00:22:49,950
>> Right.

440
00:22:49,950 --> 00:22:51,190
So they want it to be able to keep this

441
00:22:51,190 --> 00:22:54,400
service running around even if nobody was
talking to it.

442
00:22:54,400 --> 00:22:55,080
Which is kind of funny.

443
00:22:55,080 --> 00:22:56,500
That kind of flies in the face of a lot

444
00:22:56,500 --> 00:22:58,750
of what they say in Android about not
doing this.

445
00:22:58,750 --> 00:23:01,380
But this is sort of a system disease
service, so I guess they figured that

446
00:23:01,380 --> 00:23:02,900
it was okay for having it running

447
00:23:02,900 --> 00:23:05,560
there in the background and consuming some
resources.

448
00:23:05,560 --> 00:23:06,390
So yeah, that's exactly right.

449
00:23:06,390 --> 00:23:09,010
So start service causes it to be launched,
and because it

450
00:23:09,010 --> 00:23:12,130
was started, it won't shut itself down
automatically, but they want it

451
00:23:12,130 --> 00:23:14,590
to be able to make AIDL calls to it so
they

452
00:23:14,590 --> 00:23:18,400
used bind service in order to get back the
appropriate binder mechanism.

453
00:23:18,400 --> 00:23:20,320
Yeah, there's some other things they could
of done to do

454
00:23:20,320 --> 00:23:22,170
that, but that was the most
straightforward way to do it.

455
00:23:22,170 --> 00:23:26,780
So that calls the onBind method, which
goes ahead and grabs the binder.

456
00:23:26,780 --> 00:23:28,480
Returns it back by the callback to

457
00:23:28,480 --> 00:23:33,270
onServiceConnected, and it goes ahead and
onServiceConnected actually

458
00:23:33,270 --> 00:23:38,160
turns around and invokes a method called
loadNetworksList,

459
00:23:38,160 --> 00:23:40,400
which is a method running in the activity.

460
00:23:40,400 --> 00:23:45,890
And this method turns around and calls to
the MBinder object in the service,

461
00:23:45,890 --> 00:23:50,960
and it invokes the start network query
method, which is a one way call.

462
00:23:50,960 --> 00:23:55,210
And then that goes ahead and starts this
lookup process, where its checking to see

463
00:23:55,210 --> 00:23:59,090
whether or not the, the underlying network

464
00:23:59,090 --> 00:24:01,720
service is, is changed, or what it's
doing.

465
00:24:01,720 --> 00:24:05,030
And this actually requires some, some sort
of registration

466
00:24:05,030 --> 00:24:08,910
with the low level radio interface layers
service mechanisms,

467
00:24:08,910 --> 00:24:12,230
which will actually deliver results back
via handlers at

468
00:24:12,230 --> 00:24:15,680
some point down the road to the network
query service.

469
00:24:15,680 --> 00:24:17,590
And when this stuff comes back at some
point

470
00:24:17,590 --> 00:24:21,270
down the road, then there's another
callback that takes

471
00:24:21,270 --> 00:24:25,480
place in the handle message callback which
is being

472
00:24:25,480 --> 00:24:28,260
driven by low level stuff from the radio
interface layer.

473
00:24:28,260 --> 00:24:32,050
It invokes a callback to invoke the on
query complete method,

474
00:24:32,050 --> 00:24:36,490
passing back the list of network providers
that are out there.

475
00:24:36,490 --> 00:24:38,900
Which are then displayed so you can see
what they look like.

476
00:24:38,900 --> 00:24:41,360
So it's, it's just this really
interesting,

477
00:24:41,360 --> 00:24:44,270
totally asynchronous use of the Broker
pattern.

478
00:24:44,270 --> 00:24:48,980
Illustrating activator, illustrating
proxy, illustrating

479
00:24:48,980 --> 00:24:50,740
the Broker, you know all

480
00:24:50,740 --> 00:24:53,430
this stuff that we've been talking about
all kind of comes

481
00:24:53,430 --> 00:24:56,170
together, and there's both, and it's
basically using an asynchronous

482
00:24:56,170 --> 00:25:01,324
communication mechanism to make everything
work together and not block anything.

483
00:25:01,324 --> 00:25:02,980
One of the most important reasons why you

484
00:25:02,980 --> 00:25:05,630
would use asynchroni of course is to avoid
blocking.

485
00:25:05,630 --> 00:25:10,950
Because that's a downside where you don't
want the main throw to control the block.

486
00:25:10,950 --> 00:25:15,131
Okay, so to summarize the Broker, you have
support

487
00:25:15,131 --> 00:25:20,180
in Android via the binder and AIDL for
Broker.

488
00:25:20,180 --> 00:25:24,870
You have support for started services,
which use the command processor pattern to

489
00:25:24,870 --> 00:25:31,450
do message passing, and in some sense
then, Broker and, and

490
00:25:31,450 --> 00:25:36,510
command processor or pattern compliments,
you can use them in different purposes.

491
00:25:36,510 --> 00:25:37,900
They sort of compete with each other.

492
00:25:37,900 --> 00:25:40,750
And if we talk about last quiz, you would
choose one over

493
00:25:40,750 --> 00:25:43,990
the over depending on the circumstance of
which you find yourself arising.

494
00:25:43,990 --> 00:25:46,850
It is your job, or the job of whoever

495
00:25:46,850 --> 00:25:50,600
you work with, to understand the tradeoff
between these patterns.

496
00:25:50,600 --> 00:25:52,530
And one of the nice things you get from

497
00:25:52,530 --> 00:25:55,280
understanding this stuff as patterns, as
opposed to just

498
00:25:55,280 --> 00:25:57,020
understanding them in terms of the
features that Android

499
00:25:57,020 --> 00:25:59,430
provides, is that it gives you a bird's
eye

500
00:25:59,430 --> 00:26:03,490
view of the tradeoffs between
architectural alternatives and, ironically

501
00:26:03,490 --> 00:26:10,070
enough, as you switch between platforms,
as you switch from Android to iOS,

502
00:26:10,070 --> 00:26:15,660
as you switch from smartphones to clouds,
or whatever you move to, you'll find that

503
00:26:15,660 --> 00:26:19,060
these patterns exist in almost all of
those different contexts.

504
00:26:19,060 --> 00:26:20,580
And once you understand the design

505
00:26:20,580 --> 00:26:22,920
alternatives and tradeoffs in terms of
patterns,

506
00:26:22,920 --> 00:26:25,980
it's a heck of a lot easier to navigate
through the design space.

507
00:26:25,980 --> 00:26:28,092
Whereas if you understand them only as

508
00:26:28,092 --> 00:26:30,666
specific details of one platform like
Android

509
00:26:30,666 --> 00:26:33,900
or Jedi or Nedi or Corba or DDS or
whatnot, then as you start

510
00:26:33,900 --> 00:26:36,738
moving around, you'll, you'll have to
relearn

511
00:26:36,738 --> 00:26:39,246
everything from the details up, which
takes

512
00:26:39,246 --> 00:26:43,822
a long time and you may miss some of the
important commonalities that exist there.

513
00:26:43,822 --> 00:26:48,557
[MUSIC]

